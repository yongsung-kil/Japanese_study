<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#1a1a2e">
<title>Êó•Êú¨Ë™ûÂ≠¶Áøí</title>
<link rel="manifest" href="manifest.json">
<link rel="icon" href="icon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="icon.svg">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700;900&family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
<style>
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; -webkit-text-size-adjust:100%; text-size-adjust:100%; }
:root {
  --bg: #1a1a2e; --bg-card: #16213e; --bg-inner: #0f3460;
  --accent: #e94560; --accent-soft: #ff6b6b; --accent-glow: rgba(233,69,96,0.3);
  --text: #eaeaea; --muted: #8892b0; --success: #00d2d3;
  --day-active: #e94560; --day-inactive: #233554;
}
html { height:var(--app-h,100vh); overflow:hidden; overscroll-behavior:none; }
body {
  height:var(--app-h,100vh); background:linear-gradient(135deg,var(--bg) 0%,#16213e 50%,#0f3460 100%);
  font-family:'Noto Sans KR',sans-serif; color:var(--text);
  display:flex; flex-direction:column; align-items:center;
  overflow:hidden; user-select:none; overscroll-behavior:none;
  padding-bottom:env(safe-area-inset-bottom,0px);
}
#app {
  width:100%; max-width:480px; height:100%;
  display:flex; flex-direction:column; align-items:center;
  overflow:hidden;
}
.header {
  width:100%; padding:10px 16px 4px;
  display:flex; justify-content:space-between; align-items:center; flex-shrink:0;
}
.logo { font-size:18px; font-weight:900; color:var(--accent); font-family:'Noto Sans JP',sans-serif; }
.logo-sub { font-size:16px; color:var(--text); font-weight:700; margin-left:6px; font-family:'Noto Sans JP','Noto Sans KR',sans-serif; }
.test-btn {
  background:var(--accent); border:none; border-radius:20px; padding:6px 14px;
  color:#fff; font-size:12px; font-weight:700; cursor:pointer;
  font-family:'Noto Sans KR',sans-serif; transition:all .2s;
}
.test-btn.disabled { background:var(--day-inactive); cursor:default; }
.days {
  width:100%; padding:4px 16px;
  display:flex; gap:6px; overflow-x:auto; scrollbar-width:none; flex-shrink:0;
}
.days::-webkit-scrollbar { display:none; }
.day-btn {
  flex:0 0 auto; border-radius:10px; padding:6px 12px;
  font-size:11px; cursor:pointer; transition:all .3s;
  font-family:'Noto Sans KR',sans-serif; border:2px solid transparent;
  background:var(--day-inactive); color:var(--muted); font-weight:400;
}
.day-btn.active {
  background:var(--day-active); color:#fff; font-weight:700;
  border-color:var(--accent); box-shadow:0 0 15px var(--accent-glow);
}
.info {
  width:100%; padding:2px 16px 4px;
  font-size:12px; color:var(--muted); font-weight:300; flex-shrink:0;
}
.card-area {
  width:calc(100% - 32px); max-width:440px; flex:1; min-height:0; max-height:58vh;
  background:linear-gradient(145deg,var(--bg-inner),var(--bg-card));
  border-radius:20px; margin:4px 0; padding:24px 20px 16px;
  display:flex; flex-direction:column; align-items:center; justify-content:center; gap:10px;
  box-shadow:0 20px 60px rgba(0,0,0,.4),0 0 40px var(--accent-glow);
  border:1px solid rgba(233,69,96,.15); position:relative;
  transition:transform .25s ease, opacity .25s ease;
}
.card-area.slide-left {
  animation:slideLeft .25s ease;
}
.card-area.slide-right {
  animation:slideRight .25s ease;
}
@keyframes slideLeft {
  0% { transform:translateX(60px); opacity:0; }
  100% { transform:translateX(0); opacity:1; }
}
@keyframes slideRight {
  0% { transform:translateX(-60px); opacity:0; }
  100% { transform:translateX(0); opacity:1; }
}
.bookmark-btn {
  position:absolute; top:16px; right:16px; background:none; border:none;
  font-size:24px; cursor:pointer; color:var(--muted); transition:all .2s; z-index:10;
}
.bookmark-btn.active { color:var(--success); filter:drop-shadow(0 0 6px rgba(0,210,211,.4)); }
.difficult-btn {
  position:absolute; top:16px; right:52px; background:none; border:none;
  font-size:22px; cursor:pointer; color:var(--muted); transition:all .2s; z-index:10;
}
.difficult-btn.active { color:#ffd700; filter:drop-shadow(0 0 6px rgba(255,215,0,.4)); }
.card-autoplay {
  position:absolute; top:16px; right:88px; background:none; border:none;
  width:28px; height:28px; cursor:pointer; z-index:10; display:flex; align-items:center; justify-content:center;
}
.card-autoplay .mini-play { display:block; width:0; height:0; border-style:solid; border-width:7px 0 7px 12px; border-color:transparent transparent transparent var(--muted); transition:all .2s; }
.card-autoplay.active .mini-play { border-color:transparent transparent transparent var(--accent); filter:drop-shadow(0 0 6px var(--accent-glow)); }
.card-autoplay .mini-pause { display:flex; gap:3px; align-items:center; }
.card-autoplay .mini-pause span { display:block; width:3px; height:14px; background:var(--accent); border-radius:1px; filter:drop-shadow(0 0 6px var(--accent-glow)); }
.play-dots {
  position:absolute; top:16px; left:16px; display:flex; gap:4px;
}
.dot {
  width:8px; height:8px; border-radius:50%; background:rgba(255,255,255,.15); transition:background .3s;
}
.dot.filled { background:var(--accent); }
.hiragana {
  font-size:72px; font-weight:700; color:#fff;
  font-family:'Noto Sans JP',sans-serif; letter-spacing:4px;
  text-shadow:0 0 30px var(--accent-glow); line-height:1.3; text-align:center;
  flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center;
}
.hiragana.small { font-size:54px; }
.kanji-sub {
  font-size:20px; color:var(--muted); font-weight:400; letter-spacing:2px;
  margin-top:4px; opacity:.7;
}
.romaji { font-size:16px; color:var(--muted); font-weight:300; letter-spacing:2px; }
.meaning {
  font-size:18px; font-weight:500; color:var(--text); border-radius:8px;
  padding:8px 20px; cursor:pointer; transition:all .3s; text-align:center; min-width:120px;
}
.meaning.hidden { color:transparent; background:rgba(255,255,255,.08); }
.example-area { display:flex; align-items:center; justify-content:center; gap:6px; margin:8px 0 4px; }
.example-speak { position:relative; flex:0 0 auto; background:none; border:none; color:var(--accent); font-size:16px; cursor:pointer; padding:0; width:24px; height:24px; display:flex; align-items:center; justify-content:center; transition:color .2s; }
.example-speak::before { content:""; position:absolute; inset:-16px; }
.example-speak:active { opacity:.5; }
.example-speak.speaking { color:#ffd700; animation:ex-pulse .8s ease-in-out infinite; }
@keyframes ex-pulse { 0%,100%{opacity:1} 50%{opacity:.4} }
.example-text { text-align:center; pointer-events:none; }
.example-jp { font-size:14px; color:var(--accent); }
.example-meaning { font-size:12px; color:var(--muted); margin-top:2px; }
.card-bottom {
  flex-shrink:0; display:flex; flex-direction:column; align-items:center; gap:4px;
}
.controls {
  width:100%; padding:8px 16px;
  display:flex; justify-content:space-between; align-items:center; flex-shrink:0;
}
.ctrl-col { display:flex; flex-direction:column; align-items:center; gap:2px; }
.speed-btn {
  background:none; border:none; color:var(--text);
  font-size:18px; font-weight:700; cursor:pointer; font-family:'Noto Sans KR',sans-serif;
}
.speed-label { font-size:10px; color:var(--muted); }
.play-btn {
  width:56px; height:56px; border-radius:50%; border:none;
  display:flex; align-items:center; justify-content:center;
  cursor:pointer; font-size:22px; color:#fff; transition:all .2s;
  background:linear-gradient(135deg,var(--accent),#c0392b);
  box-shadow:0 4px 25px var(--accent-glow);
}
.play-btn.playing { background:linear-gradient(135deg,var(--accent),var(--accent-soft)); }
.play-icon { display:block; width:0; height:0; border-style:solid; border-width:10px 0 10px 18px; border-color:transparent transparent transparent #fff; margin-left:3px; }
.pause-icon { display:flex; gap:5px; align-items:center; }
.pause-icon span { display:block; width:5px; height:20px; background:#fff; border-radius:1px; }
.eye-btn { background:none; border:none; font-size:22px; cursor:pointer; }
.eye-btn.off { filter:grayscale(1) opacity(.4); }
.progress-bar {
  width:calc(100% - 32px); max-width:440px; height:3px;
  background:rgba(255,255,255,.06); border-radius:2px; overflow:hidden; margin:2px 0 4px; flex-shrink:0;
}
.progress-fill {
  height:100%; background:linear-gradient(90deg,var(--accent),var(--accent-soft));
  border-radius:2px; transition:width .3s;
}
.nav-row {
  width:100%; padding:0 16px 8px;
  display:flex; justify-content:space-between; flex-shrink:0;
}
.nav-btn {
  background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.1);
  border-radius:10px; padding:8px 20px; color:var(--muted);
  font-size:13px; cursor:pointer; font-family:'Noto Sans KR',sans-serif;
}
.test-actions { display:flex; gap:16px; margin-top:8px; }
.test-wrong {
  background:rgba(233,69,96,.2); border:2px solid var(--accent);
  border-radius:16px; padding:12px 28px; color:var(--accent);
  font-size:16px; font-weight:700; cursor:pointer; font-family:'Noto Sans KR',sans-serif;
}
.test-correct {
  background:rgba(0,210,211,.2); border:2px solid var(--success);
  border-radius:16px; padding:12px 28px; color:var(--success);
  font-size:16px; font-weight:700; cursor:pointer; font-family:'Noto Sans KR',sans-serif;
}
.result-page {
  width:100%; max-width:480px; padding:60px 20px; text-align:center;
  display:flex; flex-direction:column; align-items:center; gap:20px;
}
.result-emoji { font-size:48px; }
.result-title { font-size:24px; font-weight:700; }
.result-scores { display:flex; gap:30px; font-size:20px; font-weight:500; }
.result-hint { font-size:14px; color:var(--muted); line-height:1.6; }
.result-btns { display:flex; gap:12px; margin-top:10px; }
.result-retry {
  background:var(--accent); border:none; border-radius:12px;
  padding:12px 24px; color:#fff; font-size:14px; font-weight:700;
  cursor:pointer; font-family:'Noto Sans KR',sans-serif;
}
.result-back {
  background:var(--day-inactive); border:none; border-radius:12px;
  padding:12px 24px; color:#fff; font-size:14px; font-weight:500;
  cursor:pointer; font-family:'Noto Sans KR',sans-serif;
}
.back-link {
  background:none; border:none; color:var(--muted); font-size:14px;
  cursor:pointer; font-family:'Noto Sans KR',sans-serif;
}
.test-header {
  width:100%; padding:8px 16px; flex-shrink:0;
  display:flex; justify-content:space-between; align-items:center;
}
.gear-btn { background:none; border:none; font-size:22px; cursor:pointer; opacity:.6; transition:opacity .2s; }
.gear-btn:active { opacity:1; }
.settings-overlay {
  position:fixed; inset:0; background:rgba(0,0,0,.6); z-index:100;
  display:flex; align-items:flex-end; justify-content:center;
}
.settings-panel {
  width:100%; max-width:480px; background:var(--bg-card);
  border-radius:20px 20px 0 0; padding:20px 24px 32px;
  border-top:1px solid rgba(233,69,96,.2);
  max-height:85vh; max-height:85dvh; overflow-y:auto;
}
.settings-title {
  font-size:16px; font-weight:700; color:var(--text); margin-bottom:16px;
  display:flex; justify-content:space-between; align-items:center;
}
.settings-close { background:none; border:none; color:var(--muted); font-size:20px; cursor:pointer; }
.settings-row {
  display:flex; justify-content:space-between; align-items:center;
  padding:12px 0; border-bottom:1px solid rgba(255,255,255,.06);
}
.settings-label { font-size:14px; color:var(--muted); }
.settings-value {
  display:flex; align-items:center; gap:8px;
}
.settings-input {
  width:60px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.15);
  border-radius:8px; padding:6px 8px; color:var(--text); font-size:16px;
  text-align:center; font-family:'Noto Sans KR',sans-serif;
}
.settings-unit { font-size:12px; color:var(--muted); }
.menu-list {
  width:100%; flex:1; overflow-y:auto; padding:0 16px 16px; margin-top:12px;
  scrollbar-width:none;
}
.menu-list::-webkit-scrollbar { display:none; }
.menu-item {
  width:100%; background:linear-gradient(145deg,var(--bg-inner),var(--bg-card));
  border-radius:16px; padding:20px 20px; margin-bottom:12px;
  display:flex; justify-content:space-between; align-items:center;
  border:1px solid rgba(233,69,96,.1); cursor:pointer;
  transition:all .2s;
}
.menu-item:active { transform:scale(.98); border-color:var(--accent); }
.menu-item-left { display:flex; flex-direction:column; gap:4px; }
.menu-day {
  font-size:11px; color:var(--accent); font-weight:700; letter-spacing:1px;
}
.menu-title { font-size:17px; color:var(--text); font-weight:700; }
.menu-badge {
  background:rgba(233,69,96,.15); border-radius:10px; padding:4px 10px;
  font-size:12px; color:var(--accent-soft); font-weight:500; white-space:nowrap;
}
.menu-badge.clean { background:rgba(0,210,211,.1); color:var(--success); }
.menu-header {
  width:100%; padding:16px 16px 8px; flex-shrink:0;
}
.menu-header-title {
  font-size:24px; font-weight:900; color:var(--accent);
  font-family:'Noto Sans JP',sans-serif;
}
.menu-header-sub { font-size:13px; color:var(--muted); margin-top:4px; }
.refresh-btn {
  background:none; border:none; font-size:18px; cursor:pointer;
  color:var(--muted); margin-left:8px; transition:all .2s; vertical-align:middle;
}
.refresh-btn:active { color:var(--accent); transform:rotate(180deg); }
.cat-item {
  width:100%; background:linear-gradient(145deg,var(--bg-inner),var(--bg-card));
  border-radius:16px; padding:20px 20px; margin-bottom:12px;
  display:flex; justify-content:space-between; align-items:center;
  border:1px solid rgba(233,69,96,.15); cursor:pointer; transition:all .2s;
}
.cat-item:active { transform:scale(.98); border-color:var(--accent); }
.cat-title { font-size:20px; color:var(--text); font-weight:700; }
.cat-sub { font-size:12px; color:var(--muted); margin-top:4px; }
.cat-badge {
  background:rgba(233,69,96,.15); border-radius:12px; padding:6px 12px;
  font-size:13px; color:var(--accent-soft); font-weight:500; white-space:nowrap; text-align:center;
}
.cat-badge.clean { background:rgba(0,210,211,.1); color:var(--success); }
/* Grammar card */
.grammar-card {
  width:100%; flex:1; min-height:0; overflow-y:auto; scrollbar-width:none;
  padding:36px 0 4px;
}
.grammar-card::-webkit-scrollbar { display:none; }
.grammar-sentence-row {
  display:flex; align-items:center; justify-content:center; gap:8px;
  margin-bottom:8px;
}
.grammar-speak {
  flex:0 0 auto; background:none; border:none; color:var(--accent);
  font-size:18px; cursor:pointer; padding:4px; transition:color .2s;
}
.grammar-speak:active { opacity:.5; }
.grammar-sentence {
  font-size:22px; font-weight:700; color:#fff; line-height:1.5;
  font-family:'Noto Sans JP',sans-serif; text-align:center;
}
.grammar-chunk {
  font-size:15px; line-height:1.8; text-align:center; margin-bottom:3px;
  font-family:'Noto Sans JP','Noto Sans KR',sans-serif;
}
.grammar-chunk.kanji { color:var(--accent-soft); }
.grammar-chunk.hira { color:var(--muted); cursor:pointer; }
.grammar-chunk.hira .chunk-word {
  padding:2px 4px; border-radius:4px; transition:background .15s;
}
.grammar-chunk.hira .chunk-word:active { background:rgba(255,255,255,.1); }
.grammar-chunk.ko { color:var(--success); font-size:13px; }
.grammar-chunk .sep { color:rgba(255,255,255,.2); margin:0 2px; }
.grammar-divider {
  width:60%; height:1px; margin:10px auto;
  background:linear-gradient(90deg,transparent,rgba(233,69,96,.3),transparent);
}
.grammar-section-title {
  font-size:17px; color:var(--accent); font-weight:700; letter-spacing:1px;
  margin:12px 0 10px;
}
.grammar-word-table {
  width:100%; border-collapse:collapse; margin-bottom:4px;
}
.grammar-word-table td {
  padding:5px 6px; font-size:14px; border-bottom:1px solid rgba(255,255,255,.04);
}
.grammar-word-table .gw-word {
  color:#fff; font-family:'Noto Sans JP',sans-serif; font-weight:500;
  white-space:nowrap; cursor:pointer; transition:color .15s;
}
.grammar-word-table .gw-word:active { color:var(--accent); }
.grammar-word-table .gw-read { color:var(--muted); font-size:13px; }
.grammar-word-table .gw-mean { color:var(--text); }
.grammar-word-table .gw-pos {
  color:var(--accent); font-size:12px; font-weight:500;
  white-space:nowrap;
}
.grammar-point {
  background:rgba(233,69,96,.08); border-left:3px solid var(--accent);
  border-radius:0 8px 8px 0; padding:8px 12px; margin-bottom:8px;
}
.grammar-point-title {
  font-size:15px; font-weight:700; color:var(--accent-soft);
  font-family:'Noto Sans JP','Noto Sans KR',sans-serif;
}
.grammar-point-desc { font-size:14px; color:var(--muted); margin-top:3px; }
</style>
</head>
<body>

<div id="app"></div>
<div id="settings-root"></div>

<script>document.write('<script src="Í∏∞Ï¥àÎã®Ïñ¥.js?_t=' + Date.now() + '"><\/script>');</script>
<script>document.write('<script src="Ï§ëÍ∏âÎã®Ïñ¥.js?_t=' + Date.now() + '"><\/script>');</script>
<script>const WORD_DATA_MIKMAT = {};</script>
<script>const GRAMMAR_DATA_MIKMAT = {};</script>
<script>for(let i=1;i<=13;i++){document.write('<script src="ÎØ∏ÏπúÎßõÏßë/season1/ep'+String(i).padStart(2,'0')+'.js?_t='+Date.now()+'"><\/script>');}</script>
<script>[1,2,3,4,5,6,7,8,9,10,11,12,13].forEach(i=>{document.write('<script src="ÎØ∏ÏπúÎßõÏßë/season1/ep'+String(i).padStart(2,'0')+'_Grammar.js?_t='+Date.now()+'"><\/script>');});</script>
<script>var WORD_DATA_MIKMAT_REV = {};</script>
<script>var GRAMMAR_DATA_MIKMAT_REV = {};</script>
<script>document.write('<script src="ÎØ∏ÏπúÎßõÏßë_revision/season1/ep01.js?_t='+Date.now()+'"><\/script>');</script>
<script>document.write('<script src="ÎØ∏ÏπúÎßõÏßë_revision/season1/ep01_Grammar.js?_t='+Date.now()+'"><\/script>');</script>
<script>
const APP_VERSION = "v26.02.19.01:06:00";

// === ÏïàÎìúÎ°úÏù¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Î∞î ÎåÄÏùë ===
// window.innerHeightÎ°ú Ïã§Ï†ú Î≥¥Ïù¥Îäî ÏòÅÏó≠ÏùÑ Ï∏°Ï†ïÌïòÏó¨ CSS Î≥ÄÏàòÎ°ú ÏÑ§Ï†ï
function setAppHeight() {
  document.documentElement.style.setProperty('--app-h', window.innerHeight + 'px');
}
setAppHeight();
window.addEventListener('resize', setAppHeight);
window.addEventListener('orientationchange', () => setTimeout(setAppHeight, 200));

// === DATA ===
// Í∞Å Îã®Ïñ¥ ÌååÏùºÏùò Îç∞Ïù¥ÌÑ∞Î•º WORD_DATAÎ°ú ÌÜµÌï© (Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ïò§ÌîÑÏÖã Ï†ÅÏö©)
const WORD_DATA = {};
const CATEGORY_SOURCES = [
  { data: WORD_DATA_BASIC,        offset: 0   },
  { data: WORD_DATA_INTERMEDIATE, offset: 100 },
  { data: WORD_DATA_MIKMAT,       offset: 200 },
  { data: WORD_DATA_MIKMAT_REV,   offset: 300 },
];
CATEGORY_SOURCES.forEach(src => {
  Object.keys(src.data).forEach(k => {
    WORD_DATA[Number(k) + src.offset] = src.data[k];
  });
});

// Î¨∏Ïû• Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ ÌÜµÌï©
const GRAMMAR_DATA = {};
Object.keys(GRAMMAR_DATA_MIKMAT).forEach(k => {
  GRAMMAR_DATA[Number(k)] = GRAMMAR_DATA_MIKMAT[k];
});
Object.keys(GRAMMAR_DATA_MIKMAT_REV).forEach(k => {
  GRAMMAR_DATA[Number(k) + 100] = GRAMMAR_DATA_MIKMAT_REV[k];
});
const GRAMMAR_KEYS = Object.keys(GRAMMAR_DATA).map(Number).sort((a,b)=>a-b);

const DAYS = Object.keys(WORD_DATA).map(Number).sort((a,b)=>a-b);

// Ïπ¥ÌÖåÍ≥†Î¶¨ Íµ¨Ï°∞
const CATEGORIES = [
  { id: "basic", title: "Âü∫Á§éÂçòË™û", days: DAYS.filter(d => d >= 1 && d <= 99) },
  { id: "intermediate", title: "‰∏≠Á¥öÂçòË™û", days: DAYS.filter(d => d >= 100 && d <= 199) },
  { id: "mikmat", title: "ÎØ∏ÏπúÎßõÏßë(Èö£„ÅÆÂõΩ„ÅÆ„Ç∞„É´„É°„Ç§„Éà)",
    children: [
      { id: "mikmat-s1", title: "Season 1", days: DAYS.filter(d => d >= 200 && d <= 299), hasChildren: true },
      { id: "mikmat-rev", title: "Season 1 (Revision)", days: DAYS.filter(d => d >= 300 && d <= 399), hasChildren: true },
    ]
  },
];

// Í∏∞Ï°¥ jp-bm(Î™ª Ïô∏Ïö¥ Îã®Ïñ¥) Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ ‚Üí ÏÉà ÏãúÏä§ÌÖúÏùÄ jp-learned(Ïô∏Ïö¥ Îã®Ïñ¥)
if (localStorage.getItem("jp-bm")) localStorage.removeItem("jp-bm");

// ÎØ∏ÏπúÎßõÏßë ÌëúÌòÑ ÏÇ≠Ï†ú ÌõÑ Day ÌÇ§ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò (ÌôÄÏàò‚ÜíÏàúÏ∞®: 201,203,205...‚Üí201,202,203...)
(function migrateMikmatKeys() {
  if (localStorage.getItem("jp-mikmat-migrated")) return;
  const oldToNew = {203:202, 205:203, 207:204, 209:205, 211:206, 213:207, 215:208, 217:209, 219:210, 221:211, 223:212, 225:213};
  ["jp-learned","jp-difficult"].forEach(storageKey => {
    const data = JSON.parse(localStorage.getItem(storageKey) || "{}");
    let changed = false;
    Object.keys(oldToNew).forEach(oldDay => {
      const newDay = oldToNew[oldDay];
      Object.keys(data).forEach(k => {
        if (k.startsWith(oldDay + "-")) {
          const wordKey = k.substring(oldDay.toString().length + 1);
          const newKey = newDay + "-" + wordKey;
          if (!data[newKey]) { data[newKey] = data[k]; changed = true; }
          delete data[k]; changed = true;
        }
      });
    });
    // ÏßùÏàò(ÌëúÌòÑ) Day ÌÇ§ ÏÇ≠Ï†ú (202,204,206...‚ÜíÏÇ≠Ï†ú)
    Object.keys(data).forEach(k => {
      const dayNum = parseInt(k);
      if (dayNum >= 202 && dayNum <= 226 && dayNum % 2 === 0 && k.match(/^(202|204|206|208|210|212|214|216|218|220|222|224|226)-/)) {
        delete data[k]; changed = true;
      }
    });
    if (changed) localStorage.setItem(storageKey, JSON.stringify(data));
  });
  localStorage.setItem("jp-mikmat-migrated", "1");
})();

// === STATE ===
let state = {
  day: 1, idx: 0, playing: false, playCount: 0,
  showMeaning: true, showExample: localStorage.getItem("jp-show-example") !== "false",
  hideLearned: localStorage.getItem("jp-hide-learned") === "true",
  showRelated: localStorage.getItem("jp-show-related") !== "0",
  speed: 1.0, showSettings: false, slideDir: "",
  repeatDelay: Number(localStorage.getItem("jp-repeat-delay")) || 2400,
  repeatCount: Number(localStorage.getItem("jp-repeat-count")) || 3,
  fsMain: Number(localStorage.getItem("jp-fs-main")) || 72,
  fsReading: Number(localStorage.getItem("jp-fs-reading")) || 20,
  fsRomaji: Number(localStorage.getItem("jp-fs-romaji")) || 16,
  fsMeaning: Number(localStorage.getItem("jp-fs-meaning")) || 18,
  fsExample: Number(localStorage.getItem("jp-fs-example")) || 14,
  fsExampleM: Number(localStorage.getItem("jp-fs-example-m")) || 12,
  catIdx: 0, // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨
  childIdx: -1, // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÏãúÏ¶å (children ÎÇ¥ Ïù∏Îç±Ïä§, -1Ïù¥Î©¥ ÎØ∏ÏÑ†ÌÉù)
  pageTitle: "", // ÌòÑÏû¨ ÌéòÏù¥ÏßÄ Ìó§Îçî ÌÉÄÏù¥ÌãÄ (ÌÅ¥Î¶≠Ìïú Ìï≠Î™©Î™Ö)
  mode: "categories", // categories | menu | study | test | result
  testWords: [], testIdx: 0, testRevealed: false,
  testScore: { correct: 0, wrong: 0 },
  bookmarks: JSON.parse(localStorage.getItem("jp-learned") || "{}"),
  difficult: JSON.parse(localStorage.getItem("jp-difficult") || "{}"),
  listenWords: [], listenIdx: 0,
  readMode: localStorage.getItem("jp-read-mode") || (localStorage.getItem("jp-speak-korean") !== "false" ? "both" : "jp"),
  shuffle: localStorage.getItem("jp-shuffle") === "true",
  shuffleSequence: [], // ÎûúÎç§ ÏãúÌÄÄÏä§ (pre-generated)
  shuffleSeqIdx: 0, // ÌòÑÏû¨ ÎûúÎç§ ÏãúÌÄÄÏä§ ÏúÑÏπò
  shuffleHistory: [], // listening Î™®Îìú ÎûúÎç§ ÌûàÏä§ÌÜ†Î¶¨
  grammarKey: 1, // Î¨∏Ïû• Î∂ÑÏÑù ÌòÑÏû¨ ÏóêÌîºÏÜåÎìú
  grammarIdx: 0, // Î¨∏Ïû• Î∂ÑÏÑù ÌòÑÏû¨ Î¨∏Ïû• Ïù∏Îç±Ïä§
  grammarLearned: JSON.parse(localStorage.getItem("jp-grammar-learned") || "{}"),
  grammarDifficult: JSON.parse(localStorage.getItem("jp-grammar-difficult") || "{}"),
};

let playId = 0;

function dayWords(d) {
  const all = WORD_DATA[d]?.words || [];
  return state.showRelated ? all : all.filter(w => !w.rel);
}

function generateShuffleSequence() {
  const all = getAllWords();
  const seq = Array.from({length: all.length}, (_, i) => i);
  for (let i = seq.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [seq[i], seq[j]] = [seq[j], seq[i]];
  }
  state.shuffleSequence = seq;
  state.shuffleSeqIdx = 0;
}

function saveBookmarks() { localStorage.setItem("jp-learned", JSON.stringify(state.bookmarks)); }
function getWords() {
  const all = dayWords(state.day);
  if (state.hideLearned && state.mode === "study") {
    return all.filter(w => !state.bookmarks[bmKey(w)]);
  }
  return all;
}
function getAllWords() { return dayWords(state.day); }
function getCurrent() {
  if (state.mode === "test") return state.testWords[state.testIdx];
  if (state.mode === "listening") return state.listenWords[state.listenIdx];
  if (state.mode === "study" && state.shuffle) {
    if (state.shuffleSequence.length === 0 && getAllWords().length > 0) {
      generateShuffleSequence();
      state.idx = state.shuffleSequence[0] ?? 0;
    }
    return getAllWords()[state.idx];
  }
  return getWords()[state.idx];
}
function bmKey(w, day) { return (day||state.day) + "-" + w.h; }
function isBm(w) { return w ? !!state.bookmarks[bmKey(w)] : false; }
// === Ïñ¥Î†§Ïö¥ Îã®Ïñ¥ ===
function saveDifficult() { localStorage.setItem("jp-difficult", JSON.stringify(state.difficult)); }
function dfKey(w, day) { return (day||state.day) + "-" + w.h; }
function isDf(w, day) { return w ? !!state.difficult[dfKey(w, day)] : false; }
function getDifficultCount() { return Object.keys(state.difficult).length; }
function getDifficultWords() {
  const all = [];
  for (const d of DAYS) {
    dayWords(d).forEach(w => {
      if (state.difficult[d+"-"+w.h]) all.push({ ...w, day: d });
    });
  }
  return all;
}
function toggleDifficult() {
  const w = getCurrent(); if (!w) return;
  const day = state.mode === "listening" ? w.day : state.day;
  const key = day + "-" + w.h;
  if (state.difficult[key]) { delete state.difficult[key]; }
  else { state.difficult[key] = { day, h:w.h, r:w.r, m:w.m, k:w.k||"" }; }
  saveDifficult(); render();
}
function getLearnedWords() {
  const all = [];
  for (const d of DAYS) {
    dayWords(d).forEach(w => {
      if (state.bookmarks[d+"-"+w.h]) all.push({ ...w, day: d });
    });
  }
  return all;
}
function getLearnedCount() {
  return Object.keys(state.bookmarks).length;
}

// === Î¨∏Ïû•Î∂ÑÏÑù Ïô∏Ïö¥/Ïñ¥Î†§Ïö¥ Í¥ÄÎ¶¨ ===
function gKey(epKey, idx) { return "g-" + epKey + "-" + idx; }
function saveGrammarLearned() { localStorage.setItem("jp-grammar-learned", JSON.stringify(state.grammarLearned)); }
function saveGrammarDifficult() { localStorage.setItem("jp-grammar-difficult", JSON.stringify(state.grammarDifficult)); }
function isGrammarLearned(epKey, idx) { return !!state.grammarLearned[gKey(epKey, idx)]; }
function isGrammarDifficult(epKey, idx) { return !!state.grammarDifficult[gKey(epKey, idx)]; }
function toggleGrammarLearned() {
  const k = gKey(state.grammarKey, state.grammarIdx);
  if (state.grammarLearned[k]) delete state.grammarLearned[k];
  else state.grammarLearned[k] = true;
  saveGrammarLearned(); render();
}
function toggleGrammarDifficult() {
  const k = gKey(state.grammarKey, state.grammarIdx);
  if (state.grammarDifficult[k]) delete state.grammarDifficult[k];
  else state.grammarDifficult[k] = true;
  saveGrammarDifficult(); render();
}
function getGrammarLearnedCount() { return Object.keys(state.grammarLearned).length; }
function getGrammarDifficultCount() { return Object.keys(state.grammarDifficult).length; }
function getGrammarLearnedSentences() {
  const all = [];
  for (const epKey of GRAMMAR_KEYS) {
    const data = GRAMMAR_DATA[epKey];
    if (!data) continue;
    data.sentences.forEach((s, idx) => {
      if (state.grammarLearned[gKey(epKey, idx)]) all.push({ ...s, epKey, idx });
    });
  }
  return all;
}
function getGrammarDifficultSentences() {
  const all = [];
  for (const epKey of GRAMMAR_KEYS) {
    const data = GRAMMAR_DATA[epKey];
    if (!data) continue;
    data.sentences.forEach((s, idx) => {
      if (state.grammarDifficult[gKey(epKey, idx)]) all.push({ ...s, epKey, idx });
    });
  }
  return all;
}

function startListeningLearned() {
  const all = getLearnedWords();
  if (all.length === 0) { alert("Ïô∏Ïö¥ Îã®Ïñ¥Í∞Ä ÏóÜÏñ¥Ïöî!\nÌïôÏäµ Ï§ë ‚úìÏùÑ ÎàåÎü¨ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî."); return; }
  for (let i = all.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [all[i], all[j]] = [all[j], all[i]];
  }
  state.listenWords = all; state.listenIdx = 0;
  state.listenType = "learned";
  state.pageTitle = "‚úì Ïô∏Ïö¥ Îã®Ïñ¥";
  state.mode = "listening"; state.showMeaning = false;
  pushMode("listening");
  stopAuto(); render();
  setTimeout(() => speakOnce(), 300);
}
function startListening() {
  const all = getDifficultWords();
  if (all.length === 0) { alert("Ïñ¥Î†§Ïö¥ Îã®Ïñ¥Í∞Ä ÏóÜÏñ¥Ïöî!\nÌïôÏäµ Ï§ë ‚òÖÏùÑ ÎàåÎü¨ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî."); return; }
  for (let i = all.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [all[i], all[j]] = [all[j], all[i]];
  }
  state.listenWords = all; state.listenIdx = 0;
  state.listenType = "difficult";
  state.pageTitle = "‚òÖ Ïñ¥Î†§Ïö¥ Îã®Ïñ¥";
  state.mode = "listening"; state.showMeaning = false;
  pushMode("listening");
  stopAuto(); render();
  setTimeout(() => speakOnce(), 300);
}

// === Ïò§ÎîîÏò§ ÏóòÎ¶¨Î®ºÌä∏ ===
const ttsAudio = new Audio();
let ttsPlaying = false;
let speakSeq = 0;

// === PC Î∏åÎùºÏö∞Ï†Ä Ïò§ÎîîÏò§ Ïû†Í∏à Ìï¥Ï†ú (Autoplay Policy ÎåÄÏùë) ===
// Îç∞Ïä§ÌÅ¨ÌÜ± Î∏åÎùºÏö∞Ï†ÄÎäî ÏÇ¨Ïö©Ïûê ÏÉÅÌò∏ÏûëÏö© ÏóÜÏù¥ audio.play() Ï∞®Îã®
// Ï≤´ ÌÅ¥Î¶≠/ÌÑ∞Ïπò Ïãú Î¨¥Ïùå Ïû¨ÏÉùÏúºÎ°ú Ïû†Í∏à Ìï¥Ï†ú
(function() {
  let unlocked = false;
  function unlock() {
    if (unlocked) return;
    unlocked = true;
    // AudioContext Ìï¥Ï†ú (Chrome/Edge/Firefox)
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const buf = ctx.createBuffer(1, 1, 22050);
      const s = ctx.createBufferSource();
      s.buffer = buf; s.connect(ctx.destination); s.start(0);
      ctx.resume().catch(() => {});
    } catch(e) {}
    // Î≥ÑÎèÑ Audio ÏóòÎ¶¨Î®ºÌä∏Î°ú Ïû†Í∏à Ìï¥Ï†ú (ttsAudioÏôÄ Ï∂©Îèå Î∞©ÏßÄ)
    try {
      const tmp = new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=");
      tmp.volume = 0;
      tmp.play().catch(() => { unlocked = false; });
    } catch(e) {}
    document.removeEventListener('click', unlock, true);
    document.removeEventListener('touchstart', unlock, true);
  }
  document.addEventListener('click', unlock, { capture: true });
  document.addEventListener('touchstart', unlock, { capture: true });
})();

// setTimeout Í∏∞Î∞ò ÎîúÎ†àÏù¥
function playDelayAudio(delayMs, callback) {
  setTimeout(() => { if (callback) callback(); }, delayMs);
}

// === TTS BLOB Ï∫êÏãú ===
// Google TTSÎ•º BlobÏúºÎ°ú ÎØ∏Î¶¨ Îã§Ïö¥Î°úÎìú ‚Üí ÌôîÎ©¥ Í∫ºÏ†∏ÎèÑ ÎÑ§Ìä∏ÏõåÌÅ¨ ÏóÜÏù¥ Ïû¨ÏÉù Í∞ÄÎä•
let ttsBlobs = {}; // text -> blobUrl

function prefetchTTS(text) {
  if (!text || ttsBlobs[text]) return;
  const url = `https://translate.google.com/translate_tts?ie=UTF-8&tl=ja&client=tw-ob&q=${encodeURIComponent(text)}`;
  fetch(url).then(r => r.blob()).then(blob => {
    ttsBlobs[text] = URL.createObjectURL(blob);
  }).catch(() => {});
}

function getNextWordText() {
  const isListen = state.mode === "listening";
  const words = isListen ? state.listenWords : getWords();
  const idx = isListen ? state.listenIdx : state.idx;
  const w = words[idx + 1];
  if (!w) return null;
  return w.h.includes(" / ") ? w.h.split(" / ")[0] : w.h;
}

function clearTTSCache() {
  Object.values(ttsBlobs).forEach(u => URL.revokeObjectURL(u));
  ttsBlobs = {};
}

// === TTS ===
function cancelSpeak() {
  speakSeq++;
  window.speechSynthesis?.cancel();
  ttsAudio.pause();
  ttsAudio.onended = null;
  ttsAudio.onerror = null;
  ttsAudio.oncanplay = null;
  ttsPlaying = false;
  state.exSpeaking = false;
}

function speakGoogleTTS(text, cb) {
  cancelSpeak();
  const mySeq = ++speakSeq;
  let done = false;
  ttsPlaying = true;
  const onDone = (fallback) => {
    if (done || mySeq !== speakSeq) return;
    done = true;
    ttsPlaying = false;
    // Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑúÎäî speakLocal Ïä§ÌÇµ (SpeechSynthesis + setTimeout Îëò Îã§ Ïïà Îê®)
    if (fallback && document.visibilityState === 'visible') speakLocal(text, cb);
    else if (cb) cb();
  };

  // Îã§Ïùå Îã®Ïñ¥ ÌîÑÎ¶¨ÌéòÏπò (ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏóê ÎØ∏Î¶¨ Îã§Ïö¥Î°úÎìú)
  prefetchTTS(getNextWordText());

  ttsAudio.onended = () => onDone(false);
  ttsAudio.onerror = (e) => { console.warn("[TTS] audio error:", e); onDone(true); };
  ttsAudio.loop = false;
  ttsAudio.volume = 1.0;
  ttsAudio.playbackRate = state.speed;

  // Ï∫êÏãúÎêú BlobÏù¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö© (ÎÑ§Ìä∏ÏõåÌÅ¨ Î∂àÌïÑÏöî ‚Üí Î∞±Í∑∏ÎùºÏö¥Îìú OK)
  const directUrl = `https://translate.google.com/translate_tts?ie=UTF-8&tl=ja&client=tw-ob&q=${encodeURIComponent(text)}`;
  if (ttsBlobs[text]) {
    ttsAudio.src = ttsBlobs[text];
    ttsAudio.currentTime = 0;
    ttsAudio.play().catch(e => { console.warn("[TTS] cached play fail:", e.message); onDone(true); });
  } else {
    // Ï≤´ Ïû¨ÏÉù: Ï¶âÏãú play() ÏãúÎèÑ (PC Î∏åÎùºÏö∞Ï†Ä Autoplay ÎåÄÏùë)
    ttsAudio.src = directUrl;
    ttsAudio.load();
    ttsAudio.currentTime = 0;
    ttsAudio.play().catch(e => { console.warn("[TTS] direct play fail:", e.message); onDone(true); });
    fetch(directUrl).then(r => {
      if (!r.ok) { console.warn("[TTS] fetch status:", r.status); return; }
      return r.blob();
    }).then(blob => {
      if (blob && !ttsBlobs[text]) ttsBlobs[text] = URL.createObjectURL(blob);
    }).catch(e => { console.warn("[TTS] fetch fail:", e.message); });
  }
}

// SpeechSynthesis (Ìè¨Í∑∏ÎùºÏö¥Îìú Ìè¥Î∞± Ï†ÑÏö©)
function speakLocal(text, cb) {
  if (!window.speechSynthesis) { console.warn("[TTS] SpeechSynthesis ÎØ∏ÏßÄÏõê"); if(cb) cb(); return; }
  console.log("[TTS] SpeechSynthesis Ìè¥Î∞± ÏÇ¨Ïö©:", text);
  window.speechSynthesis.cancel();
  const u = new SpeechSynthesisUtterance(text);
  u.lang = "ja-JP"; u.rate = state.speed;
  const voices = window.speechSynthesis.getVoices();
  const jpVoice = voices.find(v => v.lang.startsWith("ja"));
  if (jpVoice) u.voice = jpVoice;
  else console.warn("[TTS] ÏùºÎ≥∏Ïñ¥ ÏùåÏÑ± ÏóÜÏùå. voices:", voices.length);
  let done = false;
  const finish = () => { if (done) return; done = true; if (cb) cb(); };
  u.onend = finish;
  u.onerror = (e) => { console.warn("[TTS] SpeechSynthesis error:", e); finish(); };
  window.speechSynthesis.speak(u);
  setTimeout(() => { if (!done && !window.speechSynthesis.speaking) finish(); }, 3000);
}

// TTS ÎûòÌçº (ÏµúÏÜå Ïû¨ÏÉù ÏãúÍ∞Ñ Î≥¥Ïû•)
// Google TTS Ïö∞ÏÑ† ‚Üí Ïã§Ìå® Ïãú speechSynthesis Ìè¥Î∞± (PC/Î™®Î∞îÏùº Í≥µÌÜµ)
function speak(text, cb) {
  const t0 = Date.now();
  const minMs = Math.max(500, text.length * 150 / state.speed);
  const safeCb = cb ? () => {
    const d = Date.now() - t0;
    if (d < minMs) playDelayAudio(minMs - d, cb);
    else cb();
  } : null;
  speakGoogleTTS(text, safeCb);
}

// ÌïúÍµ≠Ïñ¥ TTS (Google TTS ‚Üí speechSynthesis Ìè¥Î∞±)
function speakKo(text, cb) {
  cancelSpeak();
  const mySeq = ++speakSeq;
  let done = false;
  ttsPlaying = true;
  // [ÌíàÏÇ¨] ÌÉúÍ∑∏ Ï†úÍ±∞ ‚Üí ÍπîÎÅîÌïú ÌïúÍµ≠Ïñ¥Îßå TTSÏóê Ï†ÑÎã¨
  const clean = text.replace(/^\[.*?\]\s*/, '');
  const onDone = (fallback) => {
    if (done || mySeq !== speakSeq) return;
    done = true;
    ttsPlaying = false;
    if (fallback && document.visibilityState === 'visible') {
      speakLocalKo(clean, cb);
    } else if (cb) cb();
  };
  ttsAudio.onended = () => onDone(false);
  ttsAudio.onerror = () => onDone(true);
  ttsAudio.loop = false;
  ttsAudio.volume = 1.0;
  ttsAudio.playbackRate = state.speed;
  const cacheKey = "ko:" + clean;
  const directUrl = `https://translate.google.com/translate_tts?ie=UTF-8&tl=ko&client=tw-ob&q=${encodeURIComponent(clean)}`;

  if (ttsBlobs[cacheKey]) {
    ttsAudio.src = ttsBlobs[cacheKey];
    ttsAudio.currentTime = 0;
    ttsAudio.play().catch(() => onDone(true));
  } else {
    ttsAudio.src = directUrl;
    ttsAudio.load();
    ttsAudio.currentTime = 0;
    ttsAudio.play().catch(() => onDone(true));
    fetch(directUrl).then(r => r.blob()).then(blob => {
      if (!ttsBlobs[cacheKey]) ttsBlobs[cacheKey] = URL.createObjectURL(blob);
    }).catch(() => {});
  }
}

// SpeechSynthesis ÌïúÍµ≠Ïñ¥ Ìè¥Î∞± (Ìè¨Í∑∏ÎùºÏö¥Îìú Ï†ÑÏö©)
function speakLocalKo(text, cb) {
  if (!window.speechSynthesis) { if (cb) cb(); return; }
  window.speechSynthesis.cancel();
  const u = new SpeechSynthesisUtterance(text);
  u.lang = "ko-KR"; u.rate = state.speed;
  const voices = window.speechSynthesis.getVoices();
  const koVoice = voices.find(v => v.lang.startsWith("ko"));
  if (koVoice) u.voice = koVoice;
  let done = false;
  const finish = () => { if (done) return; done = true; if (cb) cb(); };
  u.onend = finish;
  u.onerror = finish;
  window.speechSynthesis.speak(u);
  setTimeout(() => { if (!done && !window.speechSynthesis.speaking) finish(); }, 3000);
}

// Preload voices (Ìè¥Î∞±Ïö©)
if (window.speechSynthesis) {
  window.speechSynthesis.getVoices();
  window.speechSynthesis.onvoiceschanged = () => window.speechSynthesis.getVoices();
}

// ÌôîÎ©¥ Í∫ºÏßÄÎ©¥ ÏûêÎèôÏû¨ÏÉù Ï†ïÏßÄ
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden' && state.playing) {
    stopAuto();
    render();
  }
});

// === AUTO PLAY ===
function stopAuto() {
  state.playing = false; state.playCount = 0;
  playId++;
  cancelSpeak();
  clearTTSCache();
}

function autoPlayStart() { return state.readMode !== "jp" ? -1 : 0; }

function autoPlay(count) {
  const myId = playId;
  if (!state.playing) return;
  const isListen = state.mode === "listening";
  const words = isListen ? state.listenWords : (state.shuffle ? getAllWords() : getWords());
  const idx = isListen ? state.listenIdx : state.idx;

  // count === -1: ÌïúÍµ≠Ïñ¥/ÌïúÍµ≠Ïñ¥&ÏùºÎ≥∏Ïñ¥ ÏùΩÍ∏∞
  if (count === -1) {
    const w = words[idx];
    if (!w) { stopAuto(); render(); return; }

    speakKo(w.m, () => {
      if (!state.playing || playId !== myId) return;
      if (state.readMode === "ko") {
        // ÌïúÍµ≠Ïñ¥Îßå ÏùΩÍ∏∞ ‚Üí Îã§Ïùå Îã®Ïñ¥Î°ú
        state.playCount = 0;
        playDelayAudio(400, () => {
          if (playId !== myId || !state.playing) return;
          if (state.shuffle) {
            if (isListen) {
              state.listenIdx = (state.listenIdx + 1) % words.length;
            } else {
              state.shuffleSeqIdx = (state.shuffleSeqIdx + 1) % state.shuffleSequence.length;
              state.idx = state.shuffleSequence[state.shuffleSeqIdx];
            }
            state.slideDir = "left"; render(); autoPlay(autoPlayStart());
          } else if (isListen ? state.listenIdx < words.length - 1 : idx < words.length - 1) {
            if (isListen) state.listenIdx++; else state.idx++;
            state.slideDir = "left"; render(); autoPlay(autoPlayStart());
          } else { stopAuto(); render(); }
        });
      } else {
        // ÌïúÍµ≠Ïñ¥&ÏùºÎ≥∏Ïñ¥ ‚Üí ÏùºÎ≥∏Ïñ¥ Ïû¨ÏÉùÏúºÎ°ú
        playDelayAudio(600, () => {
          if (!state.playing || playId !== myId) return;
          autoPlay(0);
        });
      }
    });
    return;
  }

  if (count >= state.repeatCount) {
    state.playCount = 0;
    playDelayAudio(400, () => {
      if (playId !== myId || !state.playing) return;
      if (state.shuffle) {
        if (isListen) {
          state.listenIdx = (state.listenIdx + 1) % words.length;
        } else {
          state.shuffleSeqIdx = (state.shuffleSeqIdx + 1) % state.shuffleSequence.length;
          state.idx = state.shuffleSequence[state.shuffleSeqIdx];
        }
        state.slideDir = "left"; render(); autoPlay(autoPlayStart());
      } else if (idx < words.length - 1) {
        if (isListen) state.listenIdx++; else state.idx++;
        state.slideDir = "left"; render(); autoPlay(autoPlayStart());
      } else { stopAuto(); render(); }
    });
    return;
  }
  state.playCount = count + 1;
  render();
  const w = words[idx];
  if (!w) { stopAuto(); render(); return; }
  const text = w.h.includes(" / ") ? w.h.split(" / ")[0] : w.h;
  speak(text, () => {
    if (!state.playing || playId !== myId) return;
    playDelayAudio(state.repeatDelay, () => {
      if (!state.playing || playId !== myId) return;
      autoPlay(count + 1);
    });
  });
}

async function togglePlay() {
  if (state.playing) { stopAuto(); }
  else {
    state.playing = true;
    render();
    autoPlay(autoPlayStart());
  }
  render();
}

// === TEST ===
function startTest() {
  // ÏïÑÏßÅ Ïô∏Ïö∞ÏßÄ ÏïäÏùÄ Îã®Ïñ¥(learnedÏóê ÏóÜÎäî Îã®Ïñ¥)Î•º ÌÖåÏä§Ìä∏
  const all = [];
  for (const d of DAYS) {
    dayWords(d).forEach(w => {
      if (!state.bookmarks[d+"-"+w.h]) all.push({ day:d, h:w.h, r:w.r, m:w.m });
    });
  }
  if (all.length === 0) { alert("Î™®Îì† Îã®Ïñ¥Î•º Ïô∏Ïõ†Ïñ¥Ïöî! üéâ"); return; }
  // ÎûúÎç§ ÏÖîÌîå
  for (let i = all.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [all[i], all[j]] = [all[j], all[i]];
  }
  state.mode = "test"; state.testWords = all; state.testIdx = 0;
  state.testRevealed = false; state.testScore = { correct:0, wrong:0 };
  pushMode("test");
  stopAuto(); render();
}

function testAnswer(correct) {
  const w = state.testWords[state.testIdx];
  const key = bmKey(w, w.day);
  if (correct) {
    state.testScore.correct++;
    // ÎßûÌûå Îã®Ïñ¥Îäî learnedÏóê Ï∂îÍ∞Ä
    state.bookmarks[key] = { day:w.day, h:w.h, r:w.r, m:w.m };
  } else {
    state.testScore.wrong++;
    // ÌãÄÎ¶∞ Îã®Ïñ¥Îäî learnedÏóêÏÑú Ï†úÍ±∞ (Ïïà Ïô∏Ïö¥ ÏÉÅÌÉú Ïú†ÏßÄ)
    delete state.bookmarks[key];
  }
  saveBookmarks();
  if (state.testIdx < state.testWords.length - 1) {
    state.testIdx++; state.testRevealed = false;
  } else { state.mode = "result"; }
  render();
}

// === SWIPE & TAP ===
let touchSX = 0, touchEX = 0, touchSY = 0, touchMoved = false;
function onTS(e) { touchSX = e.touches[0].clientX; touchSY = e.touches[0].clientY; touchEX = touchSX; touchMoved = false; }
function onTM(e) { touchEX = e.touches[0].clientX; if (Math.abs(touchEX - touchSX) > 10) touchMoved = true; }
function onTE(e) {
  const d = touchSX - touchEX;
  if (Math.abs(d) > 60) { d > 0 ? goNext() : goPrev(); return; }
  // Tap: Ïä§ÏôÄÏù¥ÌîÑ ÏïÑÎãå Í≤ΩÏö∞ Ïπ¥Îìú Ï¢å/Ïö∞ ÏòÅÏó≠ ÌÉ≠ÏúºÎ°ú Ïù¥Îèô
  // ÏÉÅÎã® 70pxÏùÄ Ï≤¥ÌÅ¨Î≤ÑÌäº/Ïä§ÌîºÏª§ ÏòÅÏó≠Ïù¥ÎØÄÎ°ú ÌÉ≠ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Ï†úÏô∏
  if (!touchMoved) {
    const card = e.currentTarget;
    const rect = card.getBoundingClientRect();
    const y = touchSY - rect.top;
    if (y < 70) return;
    const x = touchSX - rect.left;
    if (x < rect.width * 0.35) goPrev();
    else if (x > rect.width * 0.65) goNext();
  }
}
function grammarTE(e) {
  // Î¨∏Ïû•Î∂ÑÏÑù Ïπ¥Îìú: Ïä§ÏôÄÏù¥ÌîÑÎßå ÌóàÏö©, ÌÉ≠ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÎπÑÌôúÏÑ±Ìôî (TTS ÌÉ≠Í≥º Ï∂©Îèå Î∞©ÏßÄ)
  const d = touchSX - touchEX;
  if (Math.abs(d) > 60) { d > 0 ? grammarNext() : grammarPrev(); }
}
function randIdx(len) { return Math.floor(Math.random() * len); }
function pushHistory() {
  const isListen = state.mode === "listening";
  const idx = isListen ? state.listenIdx : state.idx;
  state.shuffleHistory.push(idx);
}
function goNext() {
  if (state.mode === "test") {
    if (state.testIdx < state.testWords.length - 1) { state.testIdx++; state.testRevealed = false; state.slideDir = "left"; render(); }
    return;
  }
  if (state.mode === "listening") {
    const wasPlaying = state.playing;
    if (state.shuffle) {
      if (wasPlaying) { playId++; cancelSpeak(); }
      pushHistory();
      state.listenIdx = randIdx(state.listenWords.length); state.playCount = 0; state.slideDir = "left"; render();
      if (wasPlaying) autoPlay(autoPlayStart()); else speakOnce();
    } else if (state.listenIdx < state.listenWords.length - 1) {
      if (wasPlaying) { playId++; cancelSpeak(); }
      state.listenIdx++; state.playCount = 0; state.slideDir = "left"; render();
      if (wasPlaying) autoPlay(autoPlayStart()); else speakOnce();
    }
    return;
  }
  const words = state.shuffle ? getAllWords() : getWords();
  const wasPlaying = state.playing;
  if (state.shuffle) {
    if (wasPlaying) { playId++; cancelSpeak(); }
    state.shuffleSeqIdx = (state.shuffleSeqIdx + 1) % state.shuffleSequence.length;
    state.idx = state.shuffleSequence[state.shuffleSeqIdx]; state.playCount = 0; state.slideDir = "left"; render();
    if (wasPlaying) autoPlay(autoPlayStart());
  } else if (state.idx < words.length - 1) {
    if (wasPlaying) { playId++; cancelSpeak(); }
    state.idx++; state.playCount = 0; state.slideDir = "left"; render();
    if (wasPlaying) autoPlay(autoPlayStart());
  }
}
function goPrev() {
  if (state.mode === "test") {
    if (state.testIdx > 0) { state.testIdx--; state.testRevealed = false; state.slideDir = "right"; render(); }
    return;
  }
  if (state.mode === "listening") {
    const wasPlaying = state.playing;
    if (state.shuffle && state.shuffleHistory.length > 0) {
      if (wasPlaying) { playId++; cancelSpeak(); }
      state.listenIdx = state.shuffleHistory.pop(); state.playCount = 0; state.slideDir = "right"; render();
      if (wasPlaying) autoPlay(autoPlayStart()); else speakOnce();
    } else if (!state.shuffle && state.listenIdx > 0) {
      if (wasPlaying) { playId++; cancelSpeak(); }
      state.listenIdx--; state.playCount = 0; state.slideDir = "right"; render();
      if (wasPlaying) autoPlay(autoPlayStart()); else speakOnce();
    }
    return;
  }
  const words = state.shuffle ? getAllWords() : getWords();
  const wasPlaying = state.playing;
  if (state.shuffle) {
    if (wasPlaying) { playId++; cancelSpeak(); }
    state.shuffleSeqIdx = (state.shuffleSeqIdx - 1 + state.shuffleSequence.length) % state.shuffleSequence.length;
    state.idx = state.shuffleSequence[state.shuffleSeqIdx]; state.playCount = 0; state.slideDir = "right"; render();
    if (wasPlaying) autoPlay(autoPlayStart());
  } else if (state.idx > 0) {
    if (wasPlaying) { playId++; cancelSpeak(); }
    state.idx--; state.playCount = 0; state.slideDir = "right"; render();
    if (wasPlaying) autoPlay(autoPlayStart());
  }
}

// === KEYBOARD ===
document.addEventListener("keydown", e => {
  if (state.mode === "grammar") {
    if (e.key === "ArrowRight") grammarNext();
    if (e.key === "ArrowLeft") grammarPrev();
    return;
  }
  if (state.mode === "grammarListening") {
    if (e.key === "ArrowRight") grammarListenNext();
    if (e.key === "ArrowLeft") grammarListenPrev();
    if (e.key === " ") { e.preventDefault(); state.showMeaning = !state.showMeaning; render(); }
    return;
  }
  if (e.key === "ArrowRight") goNext();
  if (e.key === "ArrowLeft") goPrev();
  if (e.key === " ") { e.preventDefault(); togglePlay(); }
});

// === Ìó¨Ìçº ===
function getActiveCat() {
  const cat = CATEGORIES[state.catIdx];
  if (cat.children && state.childIdx >= 0) return cat.children[state.childIdx];
  return cat;
}
function getCatDays(cat) {
  return cat.children ? cat.children.flatMap(c => c.days) : (cat.days || []);
}
function getSeasonGrammarKeys(cat) {
  if (!cat.days || !cat.days.length) return [];
  const offset = cat.days[0] - 1;
  return cat.days.map(d => d - offset).filter(k => GRAMMAR_DATA[k]);
}

// === ÏÉàÎ°úÍ≥†Ïπ® ===
function doRefresh() { location.reload(); }

function renderHeader(backFn, info) {
  const infoHtml = info ? ` <span style="font-weight:400;font-size:14px;color:var(--muted)">[${info}]</span>` : '';
  return `<div class="header" style="padding:16px 16px 8px">
    <div style="display:flex;align-items:center">
      <button onclick="${backFn}" style="background:none;border:none;color:var(--accent);font-size:20px;cursor:pointer;padding:0 8px 0 0;font-weight:900">‚óÄ</button>
      <span class="menu-header-title" style="font-size:20px">${state.pageTitle}${infoHtml}</span>
    </div>
  </div>`;
}

// === RENDER ===
function render() {
  const app = document.getElementById("app");
  const w = getCurrent();
  const words = getWords();

  let html = "";

  // Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Î™®Îìú
  if (state.mode === "categories") {
    html += `<div class="menu-header" style="display:flex;justify-content:space-between;align-items:flex-start">
      <div>
        <div class="menu-header-title">Êó•Êú¨Ë™ûÂ≠¶Áøí <span style="font-size:10px;color:#ffd700;font-weight:700;letter-spacing:0">${APP_VERSION}</span></div>
      </div>
      <button class="refresh-btn" style="font-size:22px;margin-top:4px" onclick="doRefresh()">‚Üª</button>
    </div>`;
    html += `<div class="menu-list">`;
    // ÌÄ¥Ï¶à (ÌïòÏúÑ Î©îÎâ¥Î°ú Ïù¥Îèô)
    const lnCount = getLearnedCount();
    const dfCount = getDifficultCount();
    const glCount = getGrammarLearnedCount();
    const gdCount = getGrammarDifficultCount();
    const quizTotal = lnCount + dfCount + glCount + gdCount;
    html += `<div class="cat-item" onclick="openQuizMenu()" style="border-color:rgba(0,210,211,.2)">
      <div>
        <div class="cat-title" style="color:var(--success)">üéß „ÇØ„Ç§„Ç∫</div>
      </div>
      <div class="cat-badge" style="background:rgba(0,210,211,.15);color:var(--success)">${quizTotal}</div>
    </div>`;
    CATEGORIES.forEach((cat, ci) => {
      const days = getCatDays(cat);
      const totalW = days.reduce((s,d) => s + dayWords(d).length, 0);
      const learnedW = days.reduce((s,d) => {
        return s + dayWords(d).filter(w => state.bookmarks[d+"-"+w.h]).length;
      }, 0);
      const pct = totalW > 0 ? Math.round(learnedW/totalW*100) : 0;
      const badgeClass = pct === 100 ? "cat-badge clean" : "cat-badge";
      const badgeText = pct === 100 ? "ÏôÑÎ£å" : pct + "%";
      const dayCount = cat.children ? cat.children.length + 'ÏãúÏ¶å' : days.length + 'Ïùº';
      html += `<div class="cat-item" onclick="openCategory(${ci})">
        <div>
          <div class="cat-title">${cat.title}</div>
        </div>
        <div class="${badgeClass}">${badgeText}</div>
      </div>`;
    });
    html += `</div>`;
    app.innerHTML = html;
    document.getElementById("settings-root").innerHTML = "";
    return;
  }

  // ÌÄ¥Ï¶à ÌïòÏúÑ Î©îÎâ¥
  if (state.mode === "quizMenu") {
    const lnCount = getLearnedCount();
    const dfCount = getDifficultCount();
    const glCount = getGrammarLearnedCount();
    const gdCount = getGrammarDifficultCount();
    html += renderHeader('goCategories()');
    html += `<div class="menu-list">`;
    // Îã®Ïñ¥ ÏÑπÏÖò
    html += `<div class="cat-item" onclick="startListeningLearned()" style="border-color:rgba(0,210,211,.2)">
      <div>
        <div class="cat-title" style="color:var(--success)">‚úì Ïô∏Ïö¥ Îã®Ïñ¥</div>
      </div>
      <div class="cat-badge" style="background:rgba(0,210,211,.15);color:var(--success)">${lnCount}</div>
    </div>`;
    html += `<div class="cat-item" onclick="startListening()" style="border-color:rgba(255,215,0,.2)">
      <div>
        <div class="cat-title" style="color:#ffd700">‚òÖ Ïñ¥Î†§Ïö¥ Îã®Ïñ¥</div>
      </div>
      <div class="cat-badge" style="background:rgba(255,215,0,.15);color:#ffd700">${dfCount}</div>
    </div>`;
    // Î¨∏Ïû•Î∂ÑÏÑù ÏÑπÏÖò
    html += `<div class="cat-item" onclick="startGrammarListeningLearned()" style="border-color:rgba(0,210,211,.2)">
      <div>
        <div class="cat-title" style="color:var(--success)">‚úì Ïô∏Ïö¥ Î¨∏Ïû•</div>
      </div>
      <div class="cat-badge" style="background:rgba(0,210,211,.15);color:var(--success)">${glCount}</div>
    </div>`;
    html += `<div class="cat-item" onclick="startGrammarListeningDifficult()" style="border-color:rgba(255,215,0,.2)">
      <div>
        <div class="cat-title" style="color:#ffd700">‚òÖ Ïñ¥Î†§Ïö¥ Î¨∏Ïû•</div>
      </div>
      <div class="cat-badge" style="background:rgba(255,215,0,.15);color:#ffd700">${gdCount}</div>
    </div>`;
    html += `</div>`;
    app.innerHTML = html;
    document.getElementById("settings-root").innerHTML = "";
    return;
  }

  // Î¨∏Ïû•Î∂ÑÏÑù Îì£Í∏∞ ÌÄ¥Ï¶à Î™®Îìú
  if (state.mode === "grammarListening") {
    const all = state.grammarListenWords || [];
    const idx = state.grammarListenIdx || 0;
    const s = all[idx];
    const total = all.length;
    const isLearned = s ? isGrammarLearned(s.epKey, s.idx) : false;
    const isDiff = s ? isGrammarDifficult(s.epKey, s.idx) : false;
    const typeLabel = state.grammarListenType === 'learned' ? 'Ïô∏Ïö¥ Î¨∏Ïû•' : 'Ïñ¥Î†§Ïö¥ Î¨∏Ïû•';
    const typeColor = state.grammarListenType === 'learned' ? 'var(--success)' : '#ffd700';

    html += renderHeader('goCategories()', `${idx+1}/${total}`);

    if (s) {
      const slideClass = state.slideDir ? " slide-" + state.slideDir : "";
      html += `<div class="card-area${slideClass}" style="justify-content:center;align-items:center"
        ontouchstart="onTS(event)" ontouchmove="onTM(event)" ontouchend="grammarListenTE(event)">`;
      state.slideDir = "";

      // Ïô∏Ïö¥/Ïñ¥Î†§Ïö¥ Î≤ÑÌäº
      html += `<button class="bookmark-btn${isLearned?' active':''}" onclick="event.stopPropagation();toggleGrammarListenLearned()" style="top:12px;right:12px">${isLearned?'‚úì':'‚úì'}</button>`;
      html += `<button class="difficult-btn${isDiff?' active':''}" onclick="event.stopPropagation();toggleGrammarListenDifficult()" style="top:12px;right:44px">${isDiff?'‚òÖ':'‚òÜ'}</button>`;

      // ÏùºÎ≥∏Ïñ¥ Î¨∏Ïû•
      html += `<div class="hiragana" style="font-size:28px;line-height:1.6;letter-spacing:2px;cursor:pointer" onclick="speakGrammar('${s.jp.replace(/'/g,"\\'")}')">${s.jp}</div>`;

      // Îúª (ÌÉ≠ÌïòÎ©¥ ÌëúÏãú)
      if (state.showMeaning) {
        html += `<div class="meaning" onclick="state.showMeaning=false;render()">${s.meaning.replace(/ \/ /g, ' ')}</div>`;
        // ÎÅäÏñ¥ÏùΩÍ∏∞
        html += `<div class="grammar-chunk hira" style="font-size:13px;margin-top:4px">${renderGrammarChunkTappable(s.reading)}</div>`;
      } else {
        html += `<div class="meaning hidden" onclick="state.showMeaning=true;render()">ÌÉ≠ÌïòÏó¨ Îúª Î≥¥Í∏∞</div>`;
      }

      html += `</div>`; // card-area
    }

    // Progress
    const pct = total > 0 ? ((idx + 1) / total * 100) : 0;
    html += `<div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>`;

    // Nav + Ïû¨ÏÉù
    html += `<div class="controls">
      <div></div>
      <button class="play-btn" onclick="if(state.grammarListenWords[state.grammarListenIdx])speakGrammar(state.grammarListenWords[state.grammarListenIdx].jp)">
        <div class="play-icon"></div>
      </button>
      <div></div>
    </div>`;
    html += `<div class="nav-row">
      <button class="nav-btn" onclick="grammarListenPrev()">‚Üê Ïù¥Ï†Ñ</button>
      <button class="nav-btn" onclick="grammarListenNext()">Îã§Ïùå ‚Üí</button>
    </div>`;

    app.innerHTML = html;
    document.getElementById("settings-root").innerHTML = "";
    return;
  }

  // ÏãúÏ¶å ÏÑ†ÌÉù Î©îÎâ¥ (Î∂ÄÎ™® Ïπ¥ÌÖåÍ≥†Î¶¨ ‚Üí ÏãúÏ¶å Î™©Î°ù)
  if (state.mode === "seasonMenu") {
    const cat = CATEGORIES[state.catIdx];
    html += renderHeader('goCategories()');
    html += `<div class="menu-list">`;
    cat.children.forEach((child, ci) => {
      const cTotalW = child.days.reduce((s,d) => s + dayWords(d).length, 0);
      const cLearnedW = child.days.reduce((s,d) => s + dayWords(d).filter(w => state.bookmarks[d+"-"+w.h]).length, 0);
      const pct = cTotalW > 0 ? Math.round(cLearnedW/cTotalW*100) : 0;
      const badgeClass = pct === 100 ? "cat-badge clean" : "cat-badge";
      const badgeText = pct === 100 ? "ÏôÑÎ£å" : pct + "%";
      html += `<div class="cat-item" onclick="openSeason(${ci})">
        <div>
          <div class="cat-title">${child.title}</div>
        </div>
        <div class="${badgeClass}">${badgeText}</div>
      </div>`;
    });
    html += `</div>`;
    app.innerHTML = html;
    document.getElementById("settings-root").innerHTML = "";
    return;
  }

  // ÏãúÏ¶å ÌïòÏúÑ Î©îÎâ¥ (Îã®Ïñ¥ / Î¨∏Ïû• Î∂ÑÏÑù)
  if (state.mode === "catSubMenu") {
    const cat = getActiveCat();
    const parentCat = CATEGORIES[state.catIdx];
    const backFn = parentCat.children ? "goSeasonMenu()" : "goCategories()";
    const totalW = cat.days.reduce((s,d) => s + dayWords(d).length, 0);
    const learnedW = cat.days.reduce((s,d) => s + dayWords(d).filter(w => state.bookmarks[d+"-"+w.h]).length, 0);
    const wordPct = totalW > 0 ? Math.round(learnedW/totalW*100) : 0;
    const gKeys = getSeasonGrammarKeys(cat);
    const totalS = gKeys.reduce((s,k) => s + (GRAMMAR_DATA[k]?.sentences.length||0), 0);
    const learnedS = gKeys.reduce((s,k) => {
      const data = GRAMMAR_DATA[k];
      if (!data) return s;
      return s + data.sentences.filter((_, i) => isGrammarLearned(k, i)).length;
    }, 0);
    const grammarPct = totalS > 0 ? Math.round(learnedS/totalS*100) : 0;
    html += renderHeader(backFn);
    html += `<div class="menu-list">`;
    // Îã®Ïñ¥
    html += `<div class="cat-item" onclick="openCatWords()">
      <div>
        <div class="cat-title">üìù ÂçòË™û</div>
      </div>
      <div class="${wordPct === 100 ? 'cat-badge clean' : 'cat-badge'}">${wordPct === 100 ? 'ÏôÑÎ£å' : wordPct + '%'}</div>
    </div>`;
    // Î¨∏Ïû• Î∂ÑÏÑù
    if (gKeys.length > 0) {
      html += `<div class="cat-item" onclick="openGrammarMenu()" style="border-color:rgba(233,69,96,.25)">
        <div>
          <div class="cat-title" style="color:var(--accent)">üìñ ÊñáÁ´†ÂàÜÊûê</div>
        </div>
        <div class="${grammarPct === 100 ? 'cat-badge clean' : 'cat-badge'}">${grammarPct === 100 ? 'ÏôÑÎ£å' : grammarPct + '%'}</div>
      </div>`;
    }
    html += `</div>`;
    app.innerHTML = html;
    document.getElementById("settings-root").innerHTML = "";
    return;
  }

  // Î¨∏Ïû• Î∂ÑÏÑù Î©îÎâ¥
  if (state.mode === "grammarMenu") {
    const _gCat = getActiveCat();
    const _gKeys = _gCat.days ? getSeasonGrammarKeys(_gCat) : GRAMMAR_KEYS;
    html += renderHeader('goBackFromGrammar()');
    html += `<div class="menu-list">`;
    for (const k of _gKeys) {
      const data = GRAMMAR_DATA[k];
      if (!data) continue;
      const glCnt = data.sentences.filter((_, i) => isGrammarLearned(k, i)).length;
      const badgeClass = glCnt === data.sentences.length ? "menu-badge clean" : "menu-badge";
      const badgeText = glCnt === data.sentences.length ? "ÏôÑÎ£å" : "‚úì " + glCnt + "/" + data.sentences.length;
      html += `<div class="menu-item" onclick="openGrammar(${k})">
        <div class="menu-item-left">
          <div class="menu-title">${data.title}</div>
        </div>
        <div class="${badgeClass}">${badgeText}</div>
      </div>`;
    }
    // Î¨∏Ïû•Î∂ÑÏÑù Ï†ÑÏ≤¥ Ï¥àÍ∏∞Ìôî Î≤ÑÌäº
    html += `<div style="padding:16px 0 8px;display:flex;gap:8px;justify-content:center">
      <button onclick="resetGrammarCatLearned()" style="background:none;border:1px solid rgba(0,210,211,.3);color:var(--success);border-radius:8px;padding:6px 14px;cursor:pointer;font-size:12px">‚úì Ïô∏Ïö¥ Î¨∏Ïû• Ï†ÑÏ≤¥ Ï¥àÍ∏∞Ìôî</button>
      <button onclick="resetGrammarCatDifficult()" style="background:none;border:1px solid rgba(255,215,0,.3);color:#ffd700;border-radius:8px;padding:6px 14px;cursor:pointer;font-size:12px">‚òÖ Ïñ¥Î†§Ïö¥ Î¨∏Ïû• Ï†ÑÏ≤¥ Ï¥àÍ∏∞Ìôî</button>
    </div>`;
    html += `</div>`;
    app.innerHTML = html;
    document.getElementById("settings-root").innerHTML = "";
    return;
  }

  // Î¨∏Ïû• Î∂ÑÏÑù Ïπ¥Îìú Î™®Îìú
  if (state.mode === "grammar") {
    const gData = GRAMMAR_DATA[state.grammarKey];
    const s = gData?.sentences[state.grammarIdx];
    const total = gData?.sentences.length || 0;

    html += renderHeader("state.pageTitle='üìñ ÊñáÁ´†ÂàÜÊûê';state.mode='grammarMenu';skipPopstate=true;history.back();render()", `${state.grammarIdx+1}/${total}`);

    if (s) {
      const slideClass = state.slideDir ? " slide-" + state.slideDir : "";
      const gLearned = isGrammarLearned(state.grammarKey, state.grammarIdx);
      const gDifficult = isGrammarDifficult(state.grammarKey, state.grammarIdx);
      html += `<div class="card-area${slideClass}" style="justify-content:flex-start;padding:16px 16px 12px;overflow:hidden"
        ontouchstart="onTS(event)" ontouchmove="onTM(event)" ontouchend="grammarTE(event)">`;
      state.slideDir = "";

      // Ïô∏Ïö¥/Ïñ¥Î†§Ïö¥ Ï≤¥ÌÅ¨ Î≤ÑÌäº
      html += `<button class="bookmark-btn${gLearned?' active':''}" onclick="event.stopPropagation();toggleGrammarLearned()" style="top:12px;right:12px">${gLearned?'‚úì':'‚úì'}</button>`;
      html += `<button class="difficult-btn${gDifficult?' active':''}" onclick="event.stopPropagation();toggleGrammarDifficult()" style="top:12px;right:44px">${gDifficult?'‚òÖ':'‚òÜ'}</button>`;

      html += `<div class="grammar-card">`;

      // ÏõêÎ¨∏ + Ïû¨ÏÉùÎ≤ÑÌäº
      html += `<div class="grammar-sentence-row">
        <button class="grammar-speak" onclick="event.stopPropagation();speakGrammar('${s.jp.replace(/'/g,"\\'")}')">üîä</button>
        <div class="grammar-sentence">${s.jp}</div>
      </div>`;

      // ÎÅäÏñ¥ÏùΩÍ∏∞ (ÌïúÏûê)
      html += `<div class="grammar-chunk kanji">${renderGrammarChunk(s.chunk)}</div>`;
      // ÎÅäÏñ¥ÏùΩÍ∏∞ (ÌûàÎùºÍ∞ÄÎÇò) - Í∞Å Ï≤≠ÌÅ¨ ÌÉ≠ÌïòÎ©¥ Î∞úÏùå
      html += `<div class="grammar-chunk hira">${renderGrammarChunkTappable(s.reading)}</div>`;
      // ÎÅäÏñ¥ÏùΩÍ∏∞ (ÌïúÍµ≠Ïñ¥)
      html += `<div class="grammar-chunk ko">${renderGrammarChunk(s.meaning)}</div>`;

      html += `<div class="grammar-divider"></div>`;

      // Îã®Ïñ¥
      html += `<div class="grammar-section-title">Îã®Ïñ¥</div>`;
      html += `<table class="grammar-word-table">`;
      s.words.forEach(wd => {
        const spkText = wd.w.replace(/'/g, "\\'");
        const display = wd.rd ? wd.w + ' <span style="color:var(--muted);font-size:13px">(' + wd.rd + ')</span>' : wd.w;
        html += `<tr>
          <td class="gw-word" onclick="event.stopPropagation();speakGrammar('${spkText}')">${display}</td>
          <td class="gw-mean">${wd.m}</td>
          <td class="gw-pos">${wd.p}</td>
        </tr>`;
      });
      html += `</table>`;

      html += `<div class="grammar-divider"></div>`;

      // Î¨∏Î≤ï
      html += `<div class="grammar-section-title">Î¨∏Î≤ï</div>`;
      s.grammar.forEach(g => {
        html += `<div class="grammar-point">
          <div class="grammar-point-title">${g.pt}</div>
          <div class="grammar-point-desc">${g.m} ‚Äî ${g.note}</div>
        </div>`;
      });

      html += `</div>`; // grammar-card
      html += `</div>`; // card-area
    }

    // Progress
    const pct = ((state.grammarIdx + 1) / total * 100);
    html += `<div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>`;

    // Nav
    html += `<div class="nav-row">
      <button class="nav-btn" onclick="grammarPrev()">‚Üê Ïù¥Ï†Ñ</button>
      <button class="nav-btn" onclick="grammarNext()">Îã§Ïùå ‚Üí</button>
    </div>`;

    app.innerHTML = html;
    document.getElementById("settings-root").innerHTML = "";
    return;
  }

  // Î©îÎâ¥ Î™®Îìú (DAY Î™©Î°ù)
  if (state.mode === "menu") {
    const cat = getActiveCat();
    const catDays = cat.days;
    const menuBackFn = cat.hasChildren ? "goMenuBack()" : "goCategories()";
    html += renderHeader(menuBackFn);
    html += `<div class="menu-list">`;
    for (const d of catDays) {
      const data = WORD_DATA[d];
      if (!data) continue;
      const dw = dayWords(d);
      const total = dw.length;
      const learnedCnt = dw.filter(w => state.bookmarks[d + "-" + w.h]).length;
      const badgeClass = learnedCnt === total ? "menu-badge clean" : "menu-badge";
      const badgeText = learnedCnt === total ? "ÏôÑÎ£å" : "‚úì " + learnedCnt + "/" + total;
      html += `<div class="menu-item" onclick="openDay(${d})">
        <div class="menu-item-left">
          <div class="menu-title">${data.title}</div>
        </div>
        <div class="${badgeClass}">${badgeText}</div>
      </div>`;
    }
    // Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ÑÏ≤¥ Ï¥àÍ∏∞Ìôî Î≤ÑÌäº
    html += `<div style="padding:16px 0 8px;display:flex;gap:8px;justify-content:center">
      <button onclick="resetCatLearned()" style="background:none;border:1px solid rgba(0,210,211,.3);color:var(--success);border-radius:8px;padding:6px 14px;cursor:pointer;font-size:12px">‚úì Ïô∏Ïö¥ Îã®Ïñ¥ Ï†ÑÏ≤¥ Ï¥àÍ∏∞Ìôî</button>
      <button onclick="resetCatDifficult()" style="background:none;border:1px solid rgba(255,215,0,.3);color:#ffd700;border-radius:8px;padding:6px 14px;cursor:pointer;font-size:12px">‚òÖ Ïñ¥Î†§Ïö¥ Îã®Ïñ¥ Ï†ÑÏ≤¥ Ï¥àÍ∏∞Ìôî</button>
    </div>`;
    html += `</div>`;
    app.innerHTML = html;
    document.getElementById("settings-root").innerHTML = "";
    return;
  }

  // Header
  if (state.mode === "listening") {
    html += renderHeader('goCategories()', `${state.listenIdx+1}/${state.listenWords.length}`);
  } else if (state.mode === "study") {
    const totalWordsCount = getAllWords().length;
    let infoCount;
    if (state.shuffle) {
      infoCount = `${state.shuffleSeqIdx+1}/${state.shuffleSequence.length} üîÄ`;
    } else if (state.hideLearned && words.length < totalWordsCount) {
      infoCount = `${words.length > 0 ? state.idx+1 : 0}/${words.length}`;
    } else {
      infoCount = `${state.idx+1}/${words.length}`;
    }
    html += renderHeader('goMenu()', infoCount);
  } else {
    html += renderHeader('goMenu()');
  }

  if (state.mode === "test") {
    html += `<div class="test-header">
      <button class="back-link" onclick="backToStudy()">‚Üê ÎèåÏïÑÍ∞ÄÍ∏∞</button>
      <span style="font-size:13px;color:var(--muted)">${state.testIdx+1}/${state.testWords.length} ¬∑ ‚úì${state.testScore.correct} ‚úó${state.testScore.wrong}</span>
    </div>`;
  }

  if (state.mode === "result") {
    html += `<div class="result-page">
      <div class="result-emoji">üéå</div>
      <div class="result-title">ÌÖåÏä§Ìä∏ ÏôÑÎ£å!</div>
      <div class="result-scores">
        <span style="color:var(--success)">‚úì ${state.testScore.correct}</span>
        <span style="color:var(--accent)">‚úó ${state.testScore.wrong}</span>
      </div>
      <div class="result-hint">ÌãÄÎ¶∞ Îã®Ïñ¥Îäî 'Ïô∏Ïö¥ Îã®Ïñ¥'ÏóêÏÑú Îπ†ÏßÄÍ≥†<br>Îã§Ïùå ÌÖåÏä§Ìä∏Ïóê Îã§Ïãú ÎÇòÏôÄÏöî</div>
      <div class="result-btns">
        <button class="result-retry" onclick="startTest()">Îã§Ïãú ÌÖåÏä§Ìä∏</button>
        <button class="result-back" onclick="backToStudy()">ÌïôÏäµÏúºÎ°ú</button>
      </div>
    </div>`;
    app.innerHTML = html;
    return;
  }

  // Ïô∏Ïö¥ Îã®Ïñ¥ Ïà®Í∏∞Í∏∞ ON + Î™®Îì† Îã®Ïñ¥ Ïô∏ÏõÄ ‚Üí ÏïàÎÇ¥ Î©îÏãúÏßÄ
  if (!w && state.mode === "study" && state.hideLearned && getAllWords().length > 0) {
    html += `<div class="card-area" style="justify-content:center;text-align:center">
      <div style="font-size:36px;margin-bottom:12px">üéâ</div>
      <div style="font-size:16px;color:var(--text);font-weight:500">Î™®Îì† Îã®Ïñ¥Î•º Ïô∏Ïõ†Ïñ¥Ïöî!</div>
      <div style="font-size:13px;color:var(--muted);margin-top:8px">ÏÑ§Ï†ïÏóêÏÑú 'Ïô∏Ïö¥ Îã®Ïñ¥ Ïà®Í∏∞Í∏∞'Î•º ÎÅÑÎ©¥<br>Ï†ÑÏ≤¥ Îã®Ïñ¥Î•º Îã§Ïãú Î≥º Ïàò ÏûàÏñ¥Ïöî</div>
    </div>`;
  }

  // Card
  if (w) {
    const isSmall = w.h.length > 6;
    const bmActive = (state.mode === "study") ? isBm(w) : false;
    const meaningHidden = state.mode === "test" ? !state.testRevealed : !state.showMeaning;

    const slideClass = state.slideDir ? " slide-" + state.slideDir : "";
    html += `<div class="card-area${slideClass}" ontouchstart="onTS(event)" ontouchmove="onTM(event)" ontouchend="onTE(event)">`;
    state.slideDir = "";

    // Í¥ÄÎ†®Îã®Ïñ¥ Î±ÉÏßÄ
    if (w.rel) {
      html += `<div style="position:absolute;top:14px;left:50%;transform:translateX(-50%);font-size:10px;color:var(--muted);background:rgba(255,255,255,.06);padding:2px 10px;border-radius:4px;pointer-events:none">Í¥ÄÎ†®</div>`;
    }

    // Bookmark + Difficult + AutoPlay (study) / Difficult only (listening)
    if (state.mode === "study") {
      html += `<button class="bookmark-btn ${bmActive?'active':''}" onclick="toggleBm()">
        ${bmActive ? "‚úì" : "‚óã"}
      </button>`;
      const dfActive = isDf(w);
      html += `<button class="difficult-btn ${dfActive?'active':''}" onclick="toggleDifficult()">
        ${dfActive ? "‚òÖ" : "‚òÜ"}
      </button>`;
      html += `<button class="card-autoplay ${state.playing?'active':''}" onclick="event.stopPropagation();togglePlay()">
        ${state.playing ? '<span class="mini-pause"><span></span><span></span></span>' : '<span class="mini-play"></span>'}
      </button>`;
    }
    if (state.mode === "listening") {
      const bmListen = w.day ? !!state.bookmarks[w.day+"-"+w.h] : false;
      html += `<button class="bookmark-btn ${bmListen?'active':''}" onclick="toggleListenBm()">
        ${bmListen ? "‚úì" : "‚óã"}
      </button>`;
      const dfActive = isDf(w, w.day);
      html += `<button class="difficult-btn ${dfActive?'active':''}" onclick="toggleDifficult()" style="color:${dfActive?'#ffd700':'var(--muted)'}; filter:${dfActive?'drop-shadow(0 0 6px rgba(255,215,0,.4))':'none'}">
        ${dfActive ? "‚òÖ" : "‚òÜ"}
      </button>`;
      html += `<button class="card-autoplay ${state.playing?'active':''}" onclick="event.stopPropagation();togglePlay()">
        ${state.playing ? '<span class="mini-pause"><span></span><span></span></span>' : '<span class="mini-play"></span>'}
      </button>`;
    }

    // Play dots
    if (state.playing && (state.mode === "study" || state.mode === "listening")) {
      html += `<div class="play-dots">
        ${Array.from({length:state.repeatCount},(_,i) => `<div class="dot ${i<state.playCount?'filled':''}"></div>`).join("")}
      </div>`;
    }


    // Î©îÏù∏ ÌÖçÏä§Ìä∏ + ÏùΩÍ∏∞ ÌëúÍ∏∞ (ÌïúÏûê ÏûàÏúºÎ©¥ ÌïúÏûêÍ∞Ä ÌÅ¨Í≤å, ÌûàÎùºÍ∞ÄÎÇòÍ∞Ä ÏûëÍ≤å)
    const mainText = w.k || w.h;
    const mainFs = isSmall ? Math.round(state.fsMain * 0.75) : state.fsMain;
    const readingSub = w.k ? `<div class="kanji-sub" style="font-size:${state.fsReading}px">${w.h}</div>` : '';
    html += `<div class="hiragana" style="font-size:${mainFs}px">${mainText}${readingSub}</div>`;

    // ÏòàÎ¨∏ (ex ÌïÑÎìúÍ∞Ä ÏûàÍ≥† showExampleÏù¥ trueÏùº ÎïåÎßå)
    if (w.ex && state.showExample) {
      html += `<div class="example-area">
        <button class="example-speak${state.exSpeaking?' speaking':''}" onclick="event.stopPropagation();speakExample()" ontouchstart="event.stopPropagation()" ontouchmove="event.stopPropagation()" ontouchend="event.stopPropagation()">üîä</button>
        <div class="example-text">
          <div class="example-jp" style="font-size:${state.fsExample}px">${w.ex}</div>
          ${w.exm ? `<div class="example-meaning" style="font-size:${state.fsExampleM}px">${w.exm}</div>` : ''}
        </div>
      </div>`;
    }

    // Bottom area (romaji + meaning + test buttons)
    html += `<div class="card-bottom">`;
    html += `<div class="romaji" style="font-size:${state.fsRomaji}px">${w.r}</div>`;
    if (state.mode === "test") {
      html += `<div class="meaning ${meaningHidden?'hidden':''}" style="font-size:${state.fsMeaning}px" onclick="revealTest()">
        ${state.testRevealed ? w.m : "ÌÉ≠ÌïòÏó¨ Îúª ÌôïÏù∏"}
      </div>`;
    } else {
      html += `<div class="meaning ${meaningHidden?'hidden':''}" style="font-size:${state.fsMeaning}px" onclick="toggleMeaning()">
        ${w.m}
      </div>`;
    }
    if (state.mode === "test" && state.testRevealed) {
      html += `<div class="test-actions">
        <button class="test-wrong" onclick="testAnswer(false)">‚úó Î™®Î•¥Í≤†Ïñ¥</button>
        <button class="test-correct" onclick="testAnswer(true)">‚úì ÏïåÏïÑ!</button>
      </div>`;
    }
    html += `</div>`;

    html += `</div>`;
  }

  // Controls (study + listening)
  if (state.mode === "study" || state.mode === "listening") {
    const speeds = [0.7, 0.85, 1.0, 1.2, 1.5];
    html += `<div class="controls">
      <div class="ctrl-col">
        <button class="gear-btn" onclick="toggleSettings()">‚öô</button>
        <span class="speed-label">ÏÑ§Ï†ï</span>
      </div>
      <div class="ctrl-col">
        <button class="speed-btn" onclick="cycleSpeed()">${state.speed}x</button>
        <span class="speed-label">Î∞∞ÏÜç</span>
      </div>
      <button class="play-btn ${state.playing?'playing':''}" onclick="togglePlay()">
        ${state.playing ? '<span class="pause-icon"><span></span><span></span></span>' : '<span class="play-icon"></span>'}
      </button>
      <div class="ctrl-col">
        <button class="eye-btn ${state.showMeaning?'':'off'}" onclick="toggleMeaning()">üëÅ</button>
        <span class="speed-label">Îúª${state.showMeaning?' Î≥¥Í∏∞':' Ïà®ÍπÄ'}</span>
      </div>
      <div class="ctrl-col">
        <button class="eye-btn ${state.showExample?'':'off'}" onclick="toggleExample()">‰æã</button>
        <span class="speed-label">ÏòàÎ¨∏${state.showExample?' Î≥¥Í∏∞':' Ïà®ÍπÄ'}</span>
      </div>
    </div>`;

    // Progress
    const isListen = state.mode === "listening";
    const pctIdx = isListen ? state.listenIdx : (state.shuffle ? state.shuffleSeqIdx : state.idx);
    const pctTotal = isListen ? state.listenWords.length : (state.shuffle ? state.shuffleSequence.length : words.length);
    const pct = ((pctIdx + 1) / pctTotal * 100);
    html += `<div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>`;
  }

  // Nav
  if (state.mode === "study" || state.mode === "test" || state.mode === "listening") {
    html += `<div class="nav-row">
      <button class="nav-btn" onclick="goPrev()">‚Üê Ïù¥Ï†Ñ</button>
      <button class="nav-btn" onclick="goNext()">Îã§Ïùå ‚Üí</button>
    </div>`;
  }

  app.innerHTML = html;

  // ÏÑ§Ï†ï Ìå®ÎÑê (app Î∞ñÏóê Î†åÎçîÎßÅ)
  const sr = document.getElementById("settings-root");
  if (state.showSettings) {
    sr.innerHTML = `<div class="settings-overlay" onclick="closeSettings(event)">
      <div class="settings-panel" onclick="event.stopPropagation()">
        <div class="settings-title">
          ÏÑ§Ï†ï
          <button class="settings-close" onclick="toggleSettings()">‚úï</button>
        </div>
        <div class="settings-row">
          <span class="settings-label">Î∞òÎ≥µ ÌöüÏàò</span>
          <div class="settings-value">
            <input class="settings-input" type="number" min="1" max="10" step="1"
              value="${state.repeatCount}"
              onchange="updateRepeatCount(this.value)">
            <span class="settings-unit">Ìöå</span>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">Î∞òÎ≥µ Í∞ÑÍ≤©</span>
          <div class="settings-value">
            <input class="settings-input" type="number" min="0" step="0.1"
              value="${(state.repeatDelay / 1000).toFixed(1)}"
              onchange="updateRepeatDelay(this.value)">
            <span class="settings-unit">Ï¥à</span>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">Ïô∏Ïö¥ Îã®Ïñ¥ Ïà®Í∏∞Í∏∞</span>
          <div class="settings-value">
            <button style="background:${state.hideLearned?'var(--success)':'var(--day-inactive)'};color:#fff;border:none;border-radius:6px;padding:4px 14px;cursor:pointer;font-size:13px"
              onclick="toggleHideLearned()">${state.hideLearned?'ON':'OFF'}</button>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">Í¥ÄÎ†®Îã®Ïñ¥ Î≥¥Í∏∞</span>
          <div class="settings-value">
            <button style="background:${state.showRelated?'var(--success)':'var(--day-inactive)'};color:#fff;border:none;border-radius:6px;padding:4px 14px;cursor:pointer;font-size:13px"
              onclick="toggleShowRelated()">${state.showRelated?'ON':'OFF'}</button>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">ÏùΩÍ∏∞</span>
          <div class="settings-value">
            <button style="background:var(--success);color:#fff;border:none;border-radius:6px;padding:4px 14px;cursor:pointer;font-size:13px;min-width:90px"
              onclick="toggleReadMode()">${state.readMode==='jp'?'ÏùºÎ≥∏Ïñ¥':state.readMode==='ko'?'ÌïúÍµ≠Ïñ¥':'Ìïú&Ïùº'}</button>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">ÎûúÎç§ Ïû¨ÏÉù</span>
          <div class="settings-value">
            <button style="background:${state.shuffle?'var(--success)':'var(--day-inactive)'};color:#fff;border:none;border-radius:6px;padding:4px 14px;cursor:pointer;font-size:13px"
              onclick="toggleShuffle()">${state.shuffle?'ON':'OFF'}</button>
          </div>
        </div>
        <div style="font-size:13px;color:var(--muted);padding:12px 0 4px;border-bottom:1px solid rgba(255,255,255,.06)">ÌòÑÏû¨ DAY Ï¥àÍ∏∞Ìôî</div>
        <div class="settings-row">
          <span class="settings-label">‚úì Ïô∏Ïö¥ Îã®Ïñ¥ Ï¥àÍ∏∞Ìôî</span>
          <div class="settings-value">
            <button style="background:var(--accent);color:#fff;border:none;border-radius:6px;padding:4px 14px;cursor:pointer;font-size:13px"
              onclick="resetDayLearned()">Ï¥àÍ∏∞Ìôî</button>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">‚òÖ Ïñ¥Î†§Ïö¥ Îã®Ïñ¥ Ï¥àÍ∏∞Ìôî</span>
          <div class="settings-value">
            <button style="background:#d4a017;color:#fff;border:none;border-radius:6px;padding:4px 14px;cursor:pointer;font-size:13px"
              onclick="resetDayDifficult()">Ï¥àÍ∏∞Ìôî</button>
          </div>
        </div>
        <div style="font-size:13px;color:var(--muted);padding:12px 0 4px;border-bottom:1px solid rgba(255,255,255,.06)">Í∏ÄÏî® ÌÅ¨Í∏∞</div>
        <div class="settings-row">
          <span class="settings-label">Î©îÏù∏ (ÌïúÏûê/Í∞ÄÎÇò)</span>
          <div class="settings-value">
            <input class="settings-input" type="number" min="20" max="120" step="2"
              value="${state.fsMain}"
              onchange="updateFontSize('fsMain','jp-fs-main',this.value)">
            <span class="settings-unit">px</span>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">ÏùΩÍ∏∞ (ÌõÑÎ¶¨Í∞ÄÎÇò)</span>
          <div class="settings-value">
            <input class="settings-input" type="number" min="10" max="60" step="2"
              value="${state.fsReading}"
              onchange="updateFontSize('fsReading','jp-fs-reading',this.value)">
            <span class="settings-unit">px</span>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">Î°úÎßàÏßÄ</span>
          <div class="settings-value">
            <input class="settings-input" type="number" min="8" max="40" step="2"
              value="${state.fsRomaji}"
              onchange="updateFontSize('fsRomaji','jp-fs-romaji',this.value)">
            <span class="settings-unit">px</span>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">Îúª</span>
          <div class="settings-value">
            <input class="settings-input" type="number" min="10" max="40" step="2"
              value="${state.fsMeaning}"
              onchange="updateFontSize('fsMeaning','jp-fs-meaning',this.value)">
            <span class="settings-unit">px</span>
          </div>
        </div>
        <div style="font-size:13px;color:var(--muted);padding:12px 0 4px;border-bottom:1px solid rgba(255,255,255,.06)">ÏòàÎ¨∏</div>
        <div class="settings-row">
          <span class="settings-label">ÏòàÎ¨∏ ÌëúÏãú</span>
          <div class="settings-value">
            <button style="background:${state.showExample?'var(--accent)':'var(--day-inactive)'};color:#fff;border:none;border-radius:6px;padding:4px 14px;cursor:pointer;font-size:13px"
              onclick="toggleExample()">${state.showExample?'ON':'OFF'}</button>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">ÏòàÎ¨∏ (ÏùºÎ≥∏Ïñ¥)</span>
          <div class="settings-value">
            <input class="settings-input" type="number" min="8" max="30" step="1"
              value="${state.fsExample}"
              onchange="updateFontSize('fsExample','jp-fs-example',this.value)">
            <span class="settings-unit">px</span>
          </div>
        </div>
        <div class="settings-row">
          <span class="settings-label">ÏòàÎ¨∏ (Îúª)</span>
          <div class="settings-value">
            <input class="settings-input" type="number" min="8" max="26" step="1"
              value="${state.fsExampleM}"
              onchange="updateFontSize('fsExampleM','jp-fs-example-m',this.value)">
            <span class="settings-unit">px</span>
          </div>
        </div>
      </div>
    </div>`;
  } else {
    sr.innerHTML = "";
  }
}

// === HISTORY (ÏïàÎìúÎ°úÏù¥Îìú Îí§Î°úÍ∞ÄÍ∏∞ ÏßÄÏõê) ===
function pushMode(mode) { history.pushState({ mode }, ""); }
let skipPopstate = false;
window.addEventListener("popstate", (e) => {
  if (skipPopstate) { skipPopstate = false; return; }
  // ÏÑ§Ï†ï Ìå®ÎÑê Ïó¥Î†§ÏûàÏúºÎ©¥ Î®ºÏ†Ä Îã´Í∏∞ (ÌûàÏä§ÌÜ†Î¶¨ Î≥µÏõê)
  if (state.showSettings) {
    history.pushState(e.state, "");
    state.showSettings = false; render(); return;
  }
  const target = e.state?.mode || "categories";
  stopAuto();
  state.mode = target;
  render();
});
// Ï¥àÍ∏∞ ÏÉÅÌÉú Îì±Î°ù
history.replaceState({ mode: "categories" }, "");

// === ACTIONS ===
function openDay(d) { state.day = d; state.pageTitle = WORD_DATA[d]?.title || ''; generateShuffleSequence(); state.idx = state.shuffle ? (state.shuffleSequence[0] ?? 0) : 0; state.mode = "study"; pushMode("study"); render(); }
function openCategory(ci) {
  state.catIdx = ci;
  state.childIdx = -1;
  const cat = CATEGORIES[ci];
  state.pageTitle = cat.title;
  if (cat.children) {
    state.mode = "seasonMenu";
    pushMode("seasonMenu");
  } else {
    state.mode = "menu";
    pushMode("menu");
  }
  render();
}
function openSeason(childIdx) {
  state.childIdx = childIdx;
  const child = getActiveCat();
  state.pageTitle = child.title;
  if (child.hasChildren) {
    state.mode = "catSubMenu";
    pushMode("catSubMenu");
  } else {
    state.mode = "menu";
    pushMode("menu");
  }
  render();
}
function goCategories() { stopAuto(); state.childIdx = -1; state.pageTitle = ""; state.mode = "categories"; skipPopstate = true; history.back(); render(); }
function goSeasonMenu() { stopAuto(); state.childIdx = -1; state.pageTitle = CATEGORIES[state.catIdx].title; state.mode = "seasonMenu"; skipPopstate = true; history.back(); render(); }
function goMenu() { stopAuto(); state.pageTitle = "üìù ÂçòË™û"; state.mode = "menu"; skipPopstate = true; history.back(); render(); }
function goMenuBack() {
  stopAuto();
  const cat = getActiveCat();
  const parentCat = CATEGORIES[state.catIdx];
  if (cat && cat.hasChildren) {
    state.pageTitle = cat.title;
    state.mode = "catSubMenu";
  } else if (parentCat.children) {
    state.pageTitle = parentCat.title;
    state.mode = "seasonMenu";
    state.childIdx = -1;
  } else {
    state.pageTitle = "";
    state.mode = "categories";
  }
  skipPopstate = true; history.back(); render();
}
function backToStudy() { stopAuto(); state.mode = "study"; skipPopstate = true; history.back(); render(); }
function toggleMeaning() { state.showMeaning = !state.showMeaning; render(); }
function toggleSettings() {
  if (!state.showSettings && state.playing) stopAuto();
  state.showSettings = !state.showSettings; render();
}
function closeSettings(e) { if (e.target === e.currentTarget) { state.showSettings = false; render(); } }
function updateRepeatCount(val) {
  const n = Math.max(1, Math.min(10, parseInt(val) || 3));
  state.repeatCount = n;
  localStorage.setItem("jp-repeat-count", n);
}
function updateRepeatDelay(val) {
  const ms = Math.max(0, Math.round(parseFloat(val) * 1000));
  state.repeatDelay = ms;
  localStorage.setItem("jp-repeat-delay", ms);
}
function updateFontSize(key, storageKey, val) {
  const n = Math.max(8, Math.min(120, parseInt(val) || state[key]));
  state[key] = n;
  localStorage.setItem(storageKey, n);
  render();
}
function revealTest() { state.testRevealed = true; render(); }
function speakOnce() {
  const w = getCurrent();
  if (w) {
    const text = w.h.includes(" / ") ? w.h.split(" / ")[0] : w.h;
    speak(text, () => {
      ttsAudio.pause();
      ttsAudio.onended = null;
      ttsAudio.onerror = null;
      ttsPlaying = false;
    });
  }
}
function speakExample() {
  const w = getCurrent();
  if (!w?.ex) return;
  stopAuto();
  state.exSpeaking = true;
  render();
  speak(w.ex, () => {
    state.exSpeaking = false;
    render();
  });
}
function toggleExample() {
  state.showExample = !state.showExample;
  localStorage.setItem("jp-show-example", state.showExample);
  render();
}
function toggleReadMode() {
  const modes = ["jp", "ko", "both"];
  const i = modes.indexOf(state.readMode);
  state.readMode = modes[(i + 1) % modes.length];
  localStorage.setItem("jp-read-mode", state.readMode);
  render();
}
function toggleShuffle() {
  state.shuffle = !state.shuffle;
  localStorage.setItem("jp-shuffle", state.shuffle);
  if (state.shuffle) {
    // ÎûúÎç§ Î™®ÎìúÎ°ú: Ï†ÄÏû•Îêú ÏãúÌÄÄÏä§ ÏúÑÏπòÎ°ú
    if (state.shuffleSequence.length > 0) {
      state.idx = state.shuffleSequence[state.shuffleSeqIdx] ?? 0;
    }
  } else {
    // ÏàúÏ∞® Î™®ÎìúÎ°ú: 0Î≤àÎ∂ÄÌÑ∞
    state.idx = 0;
  }
  render();
}
function toggleHideLearned() {
  state.hideLearned = !state.hideLearned;
  localStorage.setItem("jp-hide-learned", state.hideLearned);
  // idx Î≥¥Ï†ï: ÌïÑÌÑ∞ÎßÅÎêú Î¶¨Ïä§Ìä∏Ïóê ÎßûÍ≤å
  if (state.hideLearned && state.mode === "study" && !state.shuffle) {
    const visible = getWords();
    if (state.idx >= visible.length) state.idx = Math.max(0, visible.length - 1);
  }
  render();
}
function toggleShowRelated() {
  state.showRelated = !state.showRelated;
  localStorage.setItem("jp-show-related", state.showRelated ? "1" : "0");
  if (state.mode === "study") {
    if (state.shuffle) {
      generateShuffleSequence();
      state.shuffleSeqIdx = 0;
      state.idx = state.shuffleSequence[0] ?? 0;
    } else {
      const visible = getWords();
      if (state.idx >= visible.length) state.idx = Math.max(0, visible.length - 1);
    }
  }
  render();
}
function resetCatLearned() {
  const cat = getActiveCat();
  let count = 0;
  cat.days.forEach(d => {
    (WORD_DATA[d]?.words || []).forEach(w => { if (state.bookmarks[d+"-"+w.h]) count++; });
  });
  if (count === 0) { alert("Ï¥àÍ∏∞ÌôîÌï† Ïô∏Ïö¥ Îã®Ïñ¥Í∞Ä ÏóÜÏñ¥Ïöî."); return; }
  if (!confirm(`${cat.title} Ï†ÑÏ≤¥\nÏô∏Ïö¥ Îã®Ïñ¥ ‚úì ${count}Í∞úÎ•º Ï¥àÍ∏∞ÌôîÌï†ÍπåÏöî?`)) return;
  cat.days.forEach(d => {
    (WORD_DATA[d]?.words || []).forEach(w => { delete state.bookmarks[d+"-"+w.h]; });
  });
  saveBookmarks(); render();
}
function resetCatDifficult() {
  const cat = getActiveCat();
  let count = 0;
  cat.days.forEach(d => {
    (WORD_DATA[d]?.words || []).forEach(w => { if (state.difficult[d+"-"+w.h]) count++; });
  });
  if (count === 0) { alert("Ï¥àÍ∏∞ÌôîÌï† Ïñ¥Î†§Ïö¥ Îã®Ïñ¥Í∞Ä ÏóÜÏñ¥Ïöî."); return; }
  if (!confirm(`${cat.title} Ï†ÑÏ≤¥\nÏñ¥Î†§Ïö¥ Îã®Ïñ¥ ‚òÖ ${count}Í∞úÎ•º Ï¥àÍ∏∞ÌôîÌï†ÍπåÏöî?`)) return;
  cat.days.forEach(d => {
    (WORD_DATA[d]?.words || []).forEach(w => { delete state.difficult[d+"-"+w.h]; });
  });
  saveDifficult(); render();
}
function resetGrammarCatLearned() {
  const cat = getActiveCat();
  const gKeys = cat.days ? getSeasonGrammarKeys(cat) : GRAMMAR_KEYS;
  let count = 0;
  gKeys.forEach(k => {
    const data = GRAMMAR_DATA[k];
    if (!data) return;
    data.sentences.forEach((_, i) => { if (isGrammarLearned(k, i)) count++; });
  });
  if (count === 0) { alert("Ï¥àÍ∏∞ÌôîÌï† Ïô∏Ïö¥ Î¨∏Ïû•Ïù¥ ÏóÜÏñ¥Ïöî."); return; }
  if (!confirm(`Ïô∏Ïö¥ Î¨∏Ïû• ‚úì ${count}Í∞úÎ•º Ï¥àÍ∏∞ÌôîÌï†ÍπåÏöî?`)) return;
  gKeys.forEach(k => {
    const data = GRAMMAR_DATA[k];
    if (!data) return;
    data.sentences.forEach((_, i) => { delete state.grammarLearned[gKey(k, i)]; });
  });
  saveGrammarLearned(); render();
}
function resetGrammarCatDifficult() {
  const cat = getActiveCat();
  const gKeys = cat.days ? getSeasonGrammarKeys(cat) : GRAMMAR_KEYS;
  let count = 0;
  gKeys.forEach(k => {
    const data = GRAMMAR_DATA[k];
    if (!data) return;
    data.sentences.forEach((_, i) => { if (isGrammarDifficult(k, i)) count++; });
  });
  if (count === 0) { alert("Ï¥àÍ∏∞ÌôîÌï† Ïñ¥Î†§Ïö¥ Î¨∏Ïû•Ïù¥ ÏóÜÏñ¥Ïöî."); return; }
  if (!confirm(`Ïñ¥Î†§Ïö¥ Î¨∏Ïû• ‚òÖ ${count}Í∞úÎ•º Ï¥àÍ∏∞ÌôîÌï†ÍπåÏöî?`)) return;
  gKeys.forEach(k => {
    const data = GRAMMAR_DATA[k];
    if (!data) return;
    data.sentences.forEach((_, i) => { delete state.grammarDifficult[gKey(k, i)]; });
  });
  saveGrammarDifficult(); render();
}
function resetDayLearned() {
  const day = state.day;
  const words = WORD_DATA[day]?.words || [];
  if (words.length === 0) return;
  const count = words.filter(w => state.bookmarks[day + "-" + w.h]).length;
  if (count === 0) { alert("Ï¥àÍ∏∞ÌôîÌï† Ïô∏Ïö¥ Îã®Ïñ¥Í∞Ä ÏóÜÏñ¥Ïöî."); return; }
  if (!confirm(`DAY ${day} (${WORD_DATA[day].title})\nÏô∏Ïö¥ Îã®Ïñ¥ ‚úì ${count}Í∞úÎ•º Ï¥àÍ∏∞ÌôîÌï†ÍπåÏöî?`)) return;
  words.forEach(w => { delete state.bookmarks[day + "-" + w.h]; });
  saveBookmarks();
  state.idx = 0;
  render();
}
function resetDayDifficult() {
  const day = state.day;
  const words = WORD_DATA[day]?.words || [];
  if (words.length === 0) return;
  const count = words.filter(w => state.difficult[day + "-" + w.h]).length;
  if (count === 0) { alert("Ï¥àÍ∏∞ÌôîÌï† Ïñ¥Î†§Ïö¥ Îã®Ïñ¥Í∞Ä ÏóÜÏñ¥Ïöî."); return; }
  if (!confirm(`DAY ${day} (${WORD_DATA[day].title})\nÏñ¥Î†§Ïö¥ Îã®Ïñ¥ ‚òÖ ${count}Í∞úÎ•º Ï¥àÍ∏∞ÌôîÌï†ÍπåÏöî?`)) return;
  words.forEach(w => { delete state.difficult[day + "-" + w.h]; });
  saveDifficult();
  render();
}
function toggleListenBm() {
  const w = getCurrent(); if (!w || !w.day) return;
  const key = w.day + "-" + w.h;
  if (state.bookmarks[key]) { delete state.bookmarks[key]; }
  else { state.bookmarks[key] = { day:w.day, h:w.h, r:w.r, m:w.m }; }
  saveBookmarks(); render();
}
function toggleBm() {
  const w = getCurrent(); if (!w) return;
  const key = bmKey(w);
  const wasLearned = !!state.bookmarks[key];
  if (wasLearned) { delete state.bookmarks[key]; }
  else { state.bookmarks[key] = { day:state.day, h:w.h, r:w.r, m:w.m }; }
  saveBookmarks();
  // Ïô∏Ïö¥ Îã®Ïñ¥ Ïà®Í∏∞Í∏∞ ON ÏÉÅÌÉúÏóêÏÑú Ïô∏Ïö¥ Ï≤¥ÌÅ¨ÌïòÎ©¥ ‚Üí idx Î≥¥Ï†ï + autoPlay Î¶¨ÏÖã
  if (state.hideLearned && !wasLearned && state.mode === "study" && !state.shuffle) {
    const wasPlaying = state.playing;
    if (wasPlaying) { playId++; cancelSpeak(); }
    const visible = getWords();
    if (visible.length === 0) { state.idx = 0; if (wasPlaying) stopAuto(); }
    else {
      if (state.idx >= visible.length) { state.idx = visible.length - 1; }
      if (wasPlaying) { state.playCount = 0; autoPlay(autoPlayStart()); }
    }
  }
  render();
}
function cycleSpeed() {
  const speeds = [0.7, 0.85, 1.0, 1.2, 1.5];
  const i = speeds.indexOf(state.speed);
  state.speed = speeds[(i + 1) % speeds.length];
  render();
}

// === ÌÄ¥Ï¶à Î©îÎâ¥ ===
function openQuizMenu() {
  state.pageTitle = "üéß „ÇØ„Ç§„Ç∫";
  state.mode = "quizMenu";
  pushMode("quizMenu");
  render();
}

// === Î¨∏Ïû•Î∂ÑÏÑù ÌÄ¥Ï¶à ===
function startGrammarListeningLearned() {
  const all = getGrammarLearnedSentences();
  if (all.length === 0) { alert("Ïô∏Ïö¥ Î¨∏Ïû•Ïù¥ ÏóÜÏñ¥Ïöî!\nÎ¨∏Ïû• Î∂ÑÏÑùÏóêÏÑú ‚úìÏùÑ ÎàåÎü¨ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî."); return; }
  for (let i = all.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [all[i], all[j]] = [all[j], all[i]];
  }
  state.grammarListenWords = all;
  state.grammarListenIdx = 0;
  state.grammarListenType = "learned";
  state.pageTitle = "‚úì Ïô∏Ïö¥ Î¨∏Ïû•";
  state.mode = "grammarListening";
  state.showMeaning = false;
  pushMode("grammarListening");
  stopAuto(); render();
  setTimeout(() => speakGrammar(all[0].jp), 300);
}
function startGrammarListeningDifficult() {
  const all = getGrammarDifficultSentences();
  if (all.length === 0) { alert("Ïñ¥Î†§Ïö¥ Î¨∏Ïû•Ïù¥ ÏóÜÏñ¥Ïöî!\nÎ¨∏Ïû• Î∂ÑÏÑùÏóêÏÑú ‚òÖÏùÑ ÎàåÎü¨ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî."); return; }
  for (let i = all.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [all[i], all[j]] = [all[j], all[i]];
  }
  state.grammarListenWords = all;
  state.grammarListenIdx = 0;
  state.grammarListenType = "difficult";
  state.pageTitle = "‚òÖ Ïñ¥Î†§Ïö¥ Î¨∏Ïû•";
  state.mode = "grammarListening";
  state.showMeaning = false;
  pushMode("grammarListening");
  stopAuto(); render();
  setTimeout(() => speakGrammar(all[0].jp), 300);
}
function grammarListenNext() {
  if (state.grammarListenIdx < state.grammarListenWords.length - 1) {
    state.grammarListenIdx++;
    state.showMeaning = false;
    state.slideDir = "left";
    render();
    const s = state.grammarListenWords[state.grammarListenIdx];
    if (s) setTimeout(() => speakGrammar(s.jp), 200);
  }
}
function grammarListenPrev() {
  if (state.grammarListenIdx > 0) {
    state.grammarListenIdx--;
    state.showMeaning = false;
    state.slideDir = "right";
    render();
    const s = state.grammarListenWords[state.grammarListenIdx];
    if (s) setTimeout(() => speakGrammar(s.jp), 200);
  }
}
function grammarListenTE(e) {
  const d = e.changedTouches[0].clientX - touchSX;
  if (Math.abs(d) > 60) { d > 0 ? grammarListenPrev() : grammarListenNext(); }
}
function toggleGrammarListenLearned() {
  const s = state.grammarListenWords[state.grammarListenIdx];
  if (!s) return;
  const k = gKey(s.epKey, s.idx);
  if (state.grammarLearned[k]) delete state.grammarLearned[k];
  else state.grammarLearned[k] = true;
  saveGrammarLearned(); render();
}
function toggleGrammarListenDifficult() {
  const s = state.grammarListenWords[state.grammarListenIdx];
  if (!s) return;
  const k = gKey(s.epKey, s.idx);
  if (state.grammarDifficult[k]) delete state.grammarDifficult[k];
  else state.grammarDifficult[k] = true;
  saveGrammarDifficult(); render();
}

// === GRAMMAR ===
function openCatWords() {
  state.pageTitle = "üìù ÂçòË™û";
  state.mode = "menu";
  pushMode("menu");
  render();
}
function goBackFromGrammar() {
  const cat = getActiveCat();
  if (cat && cat.hasChildren) {
    state.pageTitle = cat.title;
    state.mode = "catSubMenu";
  } else {
    state.pageTitle = "";
    state.mode = "categories";
  }
  skipPopstate = true;
  history.back();
  render();
}
function openGrammarMenu() {
  state.pageTitle = "üìñ ÊñáÁ´†ÂàÜÊûê";
  state.mode = "grammarMenu";
  pushMode("grammarMenu");
  render();
}
function openGrammar(key) {
  state.grammarKey = key;
  state.grammarIdx = 0;
  state.pageTitle = GRAMMAR_DATA[key]?.title || '';
  state.mode = "grammar";
  pushMode("grammar");
  render();
}
function grammarNext() {
  const data = GRAMMAR_DATA[state.grammarKey];
  if (data && state.grammarIdx < data.sentences.length - 1) {
    state.grammarIdx++;
    state.slideDir = "left";
    render();
  }
}
function grammarPrev() {
  if (state.grammarIdx > 0) {
    state.grammarIdx--;
    state.slideDir = "right";
    render();
  }
}
function renderGrammarChunk(text) {
  return text.split(' / ').map((part, i, arr) =>
    `<span>${part}</span>${i < arr.length - 1 ? '<span class="sep"> / </span>' : ''}`
  ).join('');
}
function renderGrammarChunkTappable(text) {
  return text.split(' / ').map((part, i, arr) =>
    `<span class="chunk-word" onclick="event.stopPropagation();speakGrammar('${part.replace(/'/g,"\\'")}')">${part}</span>${i < arr.length - 1 ? '<span class="sep"> / </span>' : ''}`
  ).join('');
}
function speakGrammar(text) {
  cancelSpeak();
  speak(text);
}

// Init
render();
</script>
</body>
</html>
