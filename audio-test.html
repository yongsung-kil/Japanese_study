<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1a1a2e">
<title>Audio Background Test</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body {
  background:#1a1a2e; color:#eaeaea; font-family:sans-serif;
  padding:20px; max-width:480px; margin:0 auto;
}
h2 { color:#e94560; margin-bottom:12px; }
.card {
  background:#16213e; border-radius:12px; padding:16px; margin-bottom:12px;
  border:1px solid rgba(233,69,96,.15);
}
.card h3 { font-size:14px; color:#8892b0; margin-bottom:8px; }
.word { font-size:48px; text-align:center; padding:20px 0; font-family:'Noto Sans JP',sans-serif; }
.info { font-size:13px; color:#8892b0; text-align:center; margin:4px 0; }
.controls { display:flex; gap:8px; flex-wrap:wrap; margin:8px 0; }
button {
  background:#e94560; border:none; border-radius:8px; padding:10px 16px;
  color:#fff; font-size:14px; cursor:pointer; font-weight:700;
}
button.off { background:#233554; }
button.small { font-size:12px; padding:6px 12px; }
.log {
  background:#0f3460; border-radius:8px; padding:12px; margin-top:12px;
  font-size:11px; color:#8892b0; max-height:300px; overflow-y:auto;
  font-family:monospace; white-space:pre-wrap; word-break:break-all;
}
select, input {
  background:#233554; color:#eaeaea; border:1px solid #8892b0;
  border-radius:6px; padding:6px 8px; font-size:14px;
}
.row { display:flex; align-items:center; gap:8px; margin:6px 0; }
.label { font-size:13px; color:#8892b0; min-width:80px; }
.status { font-size:16px; font-weight:700; padding:8px; text-align:center; border-radius:8px; }
.status.playing { background:rgba(0,210,211,.15); color:#00d2d3; }
.status.stopped { background:rgba(233,69,96,.15); color:#e94560; }
</style>
</head>
<body>

<h2>Audio Background Test v2</h2>

<div class="card">
  <h3>Current Word</h3>
  <div class="word" id="wordDisplay">-</div>
  <div class="info" id="wordInfo">-</div>
  <div class="status stopped" id="statusBar">STOPPED</div>
</div>

<div class="card">
  <h3>Controls</h3>
  <div class="controls">
    <button onclick="togglePlay()" id="playBtn">‚ñ∂ Play</button>
    <button onclick="playPrev()" class="small">‚Üê Prev</button>
    <button onclick="playNext()" class="small">Next ‚Üí</button>
    <button onclick="speakCurrent()" class="small">üîä Once</button>
  </div>
  <div class="controls">
    <button onclick="testBeep()" class="small" style="background:#0f9b58">üîî Beep Test</button>
    <button onclick="testSpeechSynth()" class="small" style="background:#4285f4">üó£ SpeechSynth Test</button>
    <button onclick="testGoogleTTS()" class="small" style="background:#f4b400;color:#000">üåê Google TTS Test</button>
  </div>
  <div class="row">
    <span class="label">Method:</span>
    <select id="methodSelect" onchange="currentMethod=this.value;addLog('Method ‚Üí '+this.value)">
      <option value="synth">A: SpeechSynthesis (Î∏åÎùºÏö∞Ï†Ä ÎÇ¥Ïû•)</option>
      <option value="gtts">B: Google TTS (audio ÏöîÏÜå)</option>
      <option value="beep">C: Beep (Ïò§Ïã§Î†àÏù¥ÌÑ∞, ÎÑ§Ìä∏ÏõåÌÅ¨ ÏóÜÏùå)</option>
    </select>
  </div>
  <div class="row">
    <span class="label">Repeat:</span>
    <input type="number" id="repeatInput" value="3" min="1" max="10" style="width:60px">
    <span class="label">Delay:</span>
    <input type="number" id="delayInput" value="2.0" min="0" max="10" step="0.5" style="width:60px">
    <span style="font-size:12px;color:#8892b0">sec</span>
  </div>
</div>

<div class="card">
  <h3>Debug Log <button class="small" onclick="clearLog()" style="background:#233554;float:right">Clear</button></h3>
  <div class="log" id="logArea">Ready.\n</div>
</div>

<script>
// === TEST WORDS ===
const WORDS = [
  { h: "„Åä„ÅØ„Çà„ÅÜ", r: "ohayou", m: "Ï¢ãÏùÄ ÏïÑÏπ®" },
  { h: "„Åì„Çì„Å´„Å°„ÅØ", r: "konnichiwa", m: "ÏïàÎÖïÌïòÏÑ∏Ïöî" },
  { h: "„ÅÇ„Çä„Åå„Å®„ÅÜ", r: "arigatou", m: "Í∞êÏÇ¨Ìï©ÎãàÎã§" },
  { h: "„Åô„Åø„Åæ„Åõ„Çì", r: "sumimasen", m: "Ï£ÑÏÜ°Ìï©ÎãàÎã§" },
  { h: "„Åï„Çà„ÅÜ„Å™„Çâ", r: "sayounara", m: "ÏïàÎÖïÌûà Í∞ÄÏÑ∏Ïöî" },
  { h: "„ÅÑ„Åü„Å†„Åç„Åæ„Åô", r: "itadakimasu", m: "Ïûò Î®πÍ≤†ÏäµÎãàÎã§" },
  { h: "„Åä„ÇÑ„Åô„Åø", r: "oyasumi", m: "Ïûò Ïûê" },
  { h: "„ÅØ„Åò„ÇÅ„Åæ„Åó„Å¶", r: "hajimemashite", m: "Ï≤òÏùå ÎµôÍ≤†ÏäµÎãàÎã§" },
  { h: "„Åä„Å≠„Åå„ÅÑ„Åó„Åæ„Åô", r: "onegaishimasu", m: "Î∂ÄÌÉÅÌï©ÎãàÎã§" },
  { h: "„Å†„ÅÑ„Åò„Çá„ÅÜ„Å∂", r: "daijoubu", m: "Í¥úÏ∞ÆÏïÑ" },
];

// === STATE ===
let idx = 0;
let playing = false;
let playCount = 0;
let playId = 0;
let currentMethod = 'synth';
let speakSeq = 0;

// === AUDIO ELEMENTS ===
const ttsAudio = new Audio();
const bgAudio = new Audio();

// === LOGGING ===
function addLog(msg) {
  const now = new Date();
  const ts = now.toLocaleTimeString('ko-KR', {hour:'2-digit',minute:'2-digit',second:'2-digit'});
  const vis = document.visibilityState === 'visible' ? 'üëÅ' : 'üåô';
  const el = document.getElementById('logArea');
  el.textContent += `[${ts}] ${vis} ${msg}\n`;
  el.scrollTop = el.scrollHeight;
}
function clearLog() { document.getElementById('logArea').textContent = ''; }

// === SILENT WAV (for delay between words) ===
function createSilentWav(seconds) {
  const rate = 8000, samples = Math.floor(rate * seconds);
  const buf = new ArrayBuffer(44 + samples);
  const v = new DataView(buf);
  const w = (o, s) => { for (let i = 0; i < s.length; i++) v.setUint8(o + i, s.charCodeAt(i)); };
  w(0,'RIFF'); v.setUint32(4, 36+samples, true); w(8,'WAVE');
  w(12,'fmt '); v.setUint32(16,16,true); v.setUint16(20,1,true);
  v.setUint16(22,1,true); v.setUint32(24,rate,true);
  v.setUint32(28,rate,true); v.setUint16(32,1,true);
  v.setUint16(34,8,true); w(36,'data'); v.setUint32(40,samples,true);
  for (let i = 0; i < samples; i++) v.setUint8(44+i, 128);
  return URL.createObjectURL(new Blob([buf], {type:'audio/wav'}));
}

// === WAKE LOCK ===
let wakeLock = null;
async function requestWakeLock() {
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
      addLog('WakeLock acquired');
    }
  } catch(e) { addLog('WakeLock fail: ' + e.message); }
}

// === MEDIA SESSION ===
function updateMediaSession() {
  if (!('mediaSession' in navigator)) return;
  const w = WORDS[idx];
  navigator.mediaSession.metadata = new MediaMetadata({
    title: w.h + ' - ' + w.m, artist: w.r, album: 'Audio Test',
  });
  navigator.mediaSession.setActionHandler('play', () => { if (!playing) togglePlay(); });
  navigator.mediaSession.setActionHandler('pause', () => { if (playing) togglePlay(); });
  navigator.mediaSession.setActionHandler('nexttrack', () => playNext());
  navigator.mediaSession.setActionHandler('previoustrack', () => playPrev());
}

// === BACKGROUND AUDIO (silent loop to keep media session alive) ===
function startBgLoop() {
  const url = createSilentWav(5);
  bgAudio.loop = true;
  bgAudio.volume = 0.01;
  bgAudio.src = url;
  bgAudio.play().then(() => addLog('bgAudio loop started'))
    .catch(e => addLog('bgAudio fail: ' + e.message));
}
function stopBgLoop() { bgAudio.pause(); }

// === AUDIO DELAY (silent wav instead of setTimeout) ===
function playDelay(ms, cb) {
  const sec = Math.max(0.1, ms / 1000);
  const url = createSilentWav(sec);
  ttsAudio.onended = () => { URL.revokeObjectURL(url); if (cb) cb(); };
  ttsAudio.onerror = () => { URL.revokeObjectURL(url); if (cb) cb(); };
  ttsAudio.loop = false;
  ttsAudio.volume = 0.01;
  ttsAudio.playbackRate = 1.0;
  ttsAudio.src = url;
  ttsAudio.play().catch(() => { URL.revokeObjectURL(url); if (cb) cb(); });
}

// ========================================
// === TTS METHODS ===
// ========================================

// --- Method A: SpeechSynthesis (browser built-in) ---
function speakSynth(text, cb) {
  if (!window.speechSynthesis) {
    addLog('speechSynthesis not available!');
    if (cb) cb();
    return;
  }
  window.speechSynthesis.cancel();
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'ja-JP';
  u.rate = 1.0;
  const voices = window.speechSynthesis.getVoices();
  const jpVoice = voices.find(v => v.lang.startsWith('ja'));
  if (jpVoice) u.voice = jpVoice;
  let done = false;
  const finish = () => { if (done) return; done = true; addLog('synth done: ' + text); if (cb) cb(); };
  u.onend = finish;
  u.onerror = (e) => { addLog('synth error: ' + (e.error || 'unknown')); finish(); };
  window.speechSynthesis.speak(u);
  // Safety timeout
  setTimeout(() => { if (!done && !window.speechSynthesis.speaking) finish(); }, 5000);
  addLog('synth speaking: ' + text);
}

// --- Method B: Google TTS via <audio> element ---
function speakGoogleTTS(text, cb) {
  const mySeq = ++speakSeq;
  let done = false;
  const onDone = (success) => {
    if (done || mySeq !== speakSeq) return;
    done = true;
    if (!success) {
      addLog('Google TTS failed ‚Üí speechSynthesis fallback');
      speakSynth(text, cb);
      return;
    }
    addLog('Google TTS done: ' + text);
    if (cb) cb();
  };

  ttsAudio.onended = () => onDone(true);
  ttsAudio.onerror = (e) => {
    const code = ttsAudio.error ? ttsAudio.error.code : '?';
    const msg = ttsAudio.error ? ttsAudio.error.message : 'unknown';
    addLog(`Google TTS <audio> error: code=${code} msg=${msg}`);
    onDone(false);
  };
  ttsAudio.loop = false;
  ttsAudio.volume = 1.0;
  ttsAudio.playbackRate = 1.0;

  // Try client=gtx (client=tw-ob seems blocked)
  const url = `https://translate.google.com/translate_tts?ie=UTF-8&tl=ja&client=gtx&q=${encodeURIComponent(text)}`;
  addLog('Google TTS loading: ' + text);
  ttsAudio.src = url;
  ttsAudio.play()
    .then(() => addLog('Google TTS play() OK'))
    .catch(e => {
      addLog('Google TTS play() rejected: ' + e.message);
      onDone(false);
    });
}

// --- Method C: Oscillator Beep (no network, pure local) ---
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function speakBeep(text, cb) {
  try {
    const ctx = getAudioCtx();
    // Generate a short melody based on the text (different pitch per character)
    const duration = 0.15;
    const gap = 0.05;
    const now = ctx.currentTime;

    for (let i = 0; i < Math.min(text.length, 6); i++) {
      const freq = 300 + (text.charCodeAt(i) % 500);
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.value = 0.3;
      osc.connect(gain);
      gain.connect(ctx.destination);
      const start = now + i * (duration + gap);
      osc.start(start);
      osc.stop(start + duration);
    }

    const totalDur = Math.min(text.length, 6) * (duration + gap);
    addLog(`beep: ${text} (${totalDur.toFixed(1)}s)`);
    setTimeout(() => { if (cb) cb(); }, totalDur * 1000 + 100);
  } catch(e) {
    addLog('beep error: ' + e.message);
    if (cb) cb();
  }
}

// === SPEAK WRAPPER ===
function speakWord(text, cb) {
  if (currentMethod === 'synth') speakSynth(text, cb);
  else if (currentMethod === 'gtts') speakGoogleTTS(text, cb);
  else if (currentMethod === 'beep') speakBeep(text, cb);
}

// ========================================
// === INDIVIDUAL TEST BUTTONS ===
// ========================================
function testBeep() {
  addLog('--- Beep Test ---');
  speakBeep('„ÉÜ„Çπ„Éà', () => addLog('Beep test done'));
}
function testSpeechSynth() {
  addLog('--- SpeechSynthesis Test ---');
  const voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
  addLog('Voices available: ' + voices.length);
  const jaVoices = voices.filter(v => v.lang.startsWith('ja'));
  addLog('Japanese voices: ' + jaVoices.map(v => v.name).join(', '));
  speakSynth('„Åä„ÅØ„Çà„ÅÜ', () => addLog('SpeechSynth test done'));
}
function testGoogleTTS() {
  addLog('--- Google TTS Test ---');
  // Test fetch (will likely fail due to CORS)
  const url = `https://translate.google.com/translate_tts?ie=UTF-8&tl=ja&client=gtx&q=${encodeURIComponent('„Åä„ÅØ„Çà„ÅÜ')}`;
  addLog('Testing fetch (CORS)...');
  fetch(url).then(r => {
    addLog('fetch status: ' + r.status + ' type: ' + r.type);
    return r.blob();
  }).then(blob => {
    addLog('fetch OK! blob size: ' + blob.size);
  }).catch(e => {
    addLog('fetch failed (expected - CORS): ' + e.message);
  });
  // Test audio element
  addLog('Testing <audio> element...');
  speakGoogleTTS('„Åä„ÅØ„Çà„ÅÜ', () => addLog('Google TTS test done'));
}

// ========================================
// === AUTO PLAY LOOP ===
// ========================================
function autoPlay(count) {
  const myId = playId;
  if (!playing) return;

  const repeatCount = parseInt(document.getElementById('repeatInput').value) || 3;
  const delaySec = parseFloat(document.getElementById('delayInput').value) || 2.0;

  if (count >= repeatCount) {
    playCount = 0;
    addLog(`--- Word ${idx+1}/${WORDS.length} done, next ---`);
    playDelay(400, () => {
      if (playId !== myId || !playing) return;
      if (idx < WORDS.length - 1) {
        idx++;
        updateUI();
        autoPlay(0);
      } else {
        addLog('=== ALL WORDS DONE ===');
        stopPlay();
        updateUI();
      }
    });
    return;
  }

  playCount = count + 1;
  updateUI();
  updateMediaSession();

  const w = WORDS[idx];
  addLog(`Play "${w.h}" (${count+1}/${repeatCount})`);

  speakWord(w.h, () => {
    if (!playing || playId !== myId) return;
    addLog(`Delay ${delaySec}s...`);
    playDelay(delaySec * 1000, () => {
      if (!playing || playId !== myId) return;
      autoPlay(count + 1);
    });
  });
}

function togglePlay() {
  if (playing) stopPlay();
  else startPlay();
  updateUI();
}

function startPlay() {
  playing = true;
  addLog('=== START === method=' + currentMethod);
  startBgLoop();
  requestWakeLock();
  updateMediaSession();
  autoPlay(0);
}

function stopPlay() {
  playing = false;
  playCount = 0;
  playId++;
  speakSeq++;
  ttsAudio.pause(); ttsAudio.onended = null; ttsAudio.onerror = null;
  window.speechSynthesis?.cancel();
  stopBgLoop();
  if (wakeLock) { wakeLock.release(); wakeLock = null; }
  addLog('=== STOPPED ===');
}

function playNext() {
  if (idx < WORDS.length - 1) {
    const wasPlaying = playing;
    if (wasPlaying) { playId++; speakSeq++; ttsAudio.pause(); }
    idx++;
    playCount = 0;
    updateUI();
    if (wasPlaying) autoPlay(0);
  }
}

function playPrev() {
  if (idx > 0) {
    const wasPlaying = playing;
    if (wasPlaying) { playId++; speakSeq++; ttsAudio.pause(); }
    idx--;
    playCount = 0;
    updateUI();
    if (wasPlaying) autoPlay(0);
  }
}

function speakCurrent() {
  const w = WORDS[idx];
  addLog('Speak once: ' + w.h);
  speakWord(w.h, () => addLog('Speak once done'));
}

// === VISIBILITY CHANGE ===
document.addEventListener('visibilitychange', () => {
  addLog('Visibility ‚Üí ' + document.visibilityState);
  if (document.visibilityState === 'visible' && playing) {
    requestWakeLock();
  }
});

// === UI UPDATE ===
function updateUI() {
  const w = WORDS[idx];
  const repeatCount = parseInt(document.getElementById('repeatInput').value) || 3;
  document.getElementById('wordDisplay').textContent = w.h;
  document.getElementById('wordInfo').textContent =
    `${w.r} ¬∑ ${w.m} ¬∑ ${idx+1}/${WORDS.length} ¬∑ repeat ${playCount}/${repeatCount}`;

  const statusBar = document.getElementById('statusBar');
  const playBtn = document.getElementById('playBtn');
  if (playing) {
    statusBar.className = 'status playing';
    statusBar.textContent = `PLAYING (${currentMethod}) - ${w.h}`;
    playBtn.textContent = '‚è∏ Pause';
  } else {
    statusBar.className = 'status stopped';
    statusBar.textContent = 'STOPPED';
    playBtn.textContent = '‚ñ∂ Play';
  }
}

// === INIT ===
if (window.speechSynthesis) {
  window.speechSynthesis.getVoices();
  window.speechSynthesis.onvoiceschanged = () => window.speechSynthesis.getVoices();
}
updateUI();
addLog('v2 loaded. Methods: A(SpeechSynth) B(GoogleTTS) C(Beep)');
addLog('Use test buttons first to check which methods work.');
</script>
</body>
</html>
